# ë¡œì»¬ ë³€í™˜ ê¸°ëŠ¥ ì„¤ê³„

> **ëª©ì **: ì•ˆì „í•˜ê³  íš¨ìœ¨ì ì¸ ì´ë¯¸ì§€ ë³€í™˜ ì—”ì§„ êµ¬í˜„
> **í•µì‹¬ ì›ì¹™**: ì•ˆì „ì„±, ì„±ëŠ¥, ì‚¬ìš©ì í¸ì˜ì„±
> **ìµœì¢… ì—…ë°ì´íŠ¸**: 2025-10-23

---

## ğŸ¯ í•µì‹¬ ê¸°ëŠ¥ ìš”êµ¬ì‚¬í•­

### 1. ì§€ì› ì´ë¯¸ì§€ í˜•ì‹

#### ì…ë ¥ í˜•ì‹ (Source)
- **JPEG/JPG**: `.jpg`, `.jpeg`
- **PNG**: `.png`
- **BMP**: `.bmp`
- **TIFF**: `.tiff`, `.tif`
- **GIF**: `.gif` (ì •ì  ì´ë¯¸ì§€ë§Œ, ì• ë‹ˆë©”ì´ì…˜ ë¯¸ì§€ì›)

#### ì¶œë ¥ í˜•ì‹ (Target)
- **WebP**: `.webp` (ëª¨ë“  í”Œëœ)
- **AVIF**: `.avif` (Basic ì´ìƒ)

### 2. ë³€í™˜ ì˜µì…˜

| ì˜µì…˜ | ì„¤ëª… | ê¸°ë³¸ê°’ | ë²”ìœ„ |
|------|------|--------|------|
| **í’ˆì§ˆ (Quality)** | ì••ì¶• í’ˆì§ˆ ì„¤ì • | 80 | 50-100 |
| **ìµœì í™” (Optimize)** | ì¶”ê°€ ìµœì í™” ì ìš© | True | True/False |
| **í”„ë¡œê·¸ë ˆì‹œë¸Œ (Progressive)** | ì ì§„ì  ë¡œë”© ì§€ì› | True | True/False |
| **ë©”íƒ€ë°ì´í„° ë³´ì¡´** | EXIF ì •ë³´ ìœ ì§€ | False | True/False |
| **ìµœëŒ€ ë„ˆë¹„** | ë¦¬ì‚¬ì´ì¦ˆ ìµœëŒ€ ë„ˆë¹„ | 1920px | ì œí•œ ì—†ìŒ |
| **ìµœëŒ€ ë†’ì´** | ë¦¬ì‚¬ì´ì¦ˆ ìµœëŒ€ ë†’ì´ | 1080px | ì œí•œ ì—†ìŒ |
| **ë¬´ì†ì‹¤ (Lossless)** | ë¬´ì†ì‹¤ ì••ì¶• | False | True/False |

---

## ğŸ—ï¸ ë³€í™˜ ì—”ì§„ ì•„í‚¤í…ì²˜

### í´ë˜ìŠ¤ ë‹¤ì´ì–´ê·¸ë¨

```python
ImageConverter (ë©”ì¸ í´ë˜ìŠ¤)
  â”œâ”€â”€ SafeConverter (ì•ˆì „í•œ ë³€í™˜ ì²˜ë¦¬)
  â”œâ”€â”€ FormatDetector (í˜•ì‹ ê°ì§€)
  â”œâ”€â”€ QualityOptimizer (í’ˆì§ˆ ìµœì í™”)
  â”œâ”€â”€ MetadataHandler (ë©”íƒ€ë°ì´í„° ì²˜ë¦¬)
  â””â”€â”€ ErrorRecovery (ì—ëŸ¬ ë³µêµ¬)

FileScanner (íŒŒì¼ ìŠ¤ìº”)
  â”œâ”€â”€ SystemFolderFilter (ì‹œìŠ¤í…œ í´ë” ì œì™¸)
  â”œâ”€â”€ SafetyChecker (ì•ˆì „ì„± ê²€ì‚¬)
  â””â”€â”€ ProgressTracker (ì§„í–‰ ì¶”ì )

LogManager (ë¡œê·¸ ê´€ë¦¬)
  â”œâ”€â”€ ExcelLogger (Excel ë¡œê·¸)
  â”œâ”€â”€ FileLinker (íŒŒì¼ ë§í¬)
  â””â”€â”€ SheetManager (ì‹œíŠ¸ ê´€ë¦¬)
```

---

## ğŸ’» í•µì‹¬ ëª¨ë“ˆ ìƒì„¸ ì„¤ê³„

### 1. ImageConverter í´ë˜ìŠ¤

```python
class ImageConverter:
    """ì´ë¯¸ì§€ ë³€í™˜ ì—”ì§„ ë©”ì¸ í´ë˜ìŠ¤"""

    def __init__(self, config=None):
        """
        ì´ˆê¸°í™”

        Args:
            config (dict): ë³€í™˜ ì„¤ì • (ì„ íƒ)
        """
        self.config = config or self._get_default_config()
        self.subscription_manager = SubscriptionManager()
        self.daily_usage = 0
        self.user_limits = {}

    def convert(self, input_path, output_format='webp', options=None):
        """
        ë‹¨ì¼ ì´ë¯¸ì§€ ë³€í™˜

        Args:
            input_path (str/Path): ì…ë ¥ íŒŒì¼ ê²½ë¡œ
            output_format (str): ì¶œë ¥ í˜•ì‹ ('webp' or 'avif')
            options (dict): ë³€í™˜ ì˜µì…˜

        Returns:
            tuple: (ì„±ê³µ ì—¬ë¶€, ê²°ê³¼ ë©”ì‹œì§€, ì¶œë ¥ ê²½ë¡œ)
        """
        pass

    def batch_convert(self, file_paths, output_format='webp', options=None):
        """
        ë°°ì¹˜ ë³€í™˜ (ë©€í‹°ìŠ¤ë ˆë”©)

        Args:
            file_paths (list): ì…ë ¥ íŒŒì¼ ê²½ë¡œ ë¦¬ìŠ¤íŠ¸
            output_format (str): ì¶œë ¥ í˜•ì‹
            options (dict): ë³€í™˜ ì˜µì…˜

        Returns:
            list: [(ì„±ê³µ ì—¬ë¶€, ë©”ì‹œì§€, ì¶œë ¥ ê²½ë¡œ), ...]
        """
        pass

    def _safe_convert(self, input_path, output_path, options):
        """
        ì•ˆì „í•œ ë³€í™˜ (ì›ìì  ì²˜ë¦¬)

        Process:
        1. ì›ë³¸ íŒŒì¼ ì²´í¬ì„¬ ê³„ì‚°
        2. ì„ì‹œ íŒŒì¼ë¡œ ë³€í™˜
        3. ë³€í™˜ ê²°ê³¼ ê²€ì¦
        4. ì„±ê³µ ì‹œ ì›ë³¸ êµì²´
        5. ì‹¤íŒ¨ ì‹œ ì„ì‹œ íŒŒì¼ ì‚­ì œ
        """
        pass

    def _get_default_config(self):
        """ê¸°ë³¸ ì„¤ì • ë°˜í™˜"""
        return {
            'quality': 80,
            'optimize': True,
            'progressive': True,
            'preserve_metadata': False,
            'max_width': 1920,
            'max_height': 1080,
            'lossless': False,
            'backup': False
        }
```

### 2. SafeConverter í´ë˜ìŠ¤

```python
class SafeConverter:
    """ì•ˆì „í•œ ë³€í™˜ ì²˜ë¦¬ (ì›ìì  ë³€í™˜)"""

    @staticmethod
    def atomic_convert(input_path, output_format, options):
        """
        ì›ìì  ë³€í™˜ í”„ë¡œì„¸ìŠ¤

        Steps:
        1. ì…ë ¥ íŒŒì¼ ê²€ì¦
        2. ì²´í¬ì„¬ ê³„ì‚° (SHA-256)
        3. ì„ì‹œ íŒŒì¼ë¡œ ë³€í™˜
        4. ë³€í™˜ ê²°ê³¼ ê²€ì¦
        5. ë°±ì—… ìƒì„± (ì˜µì…˜)
        6. ì›ë³¸ êµì²´
        7. ì„ì‹œ íŒŒì¼ ì •ë¦¬

        Args:
            input_path (Path): ì…ë ¥ íŒŒì¼
            output_format (str): ì¶œë ¥ í˜•ì‹
            options (dict): ë³€í™˜ ì˜µì…˜

        Returns:
            tuple: (ì„±ê³µ, ë©”ì‹œì§€, ì¶œë ¥ ê²½ë¡œ)
        """
        import hashlib
        import shutil
        from PIL import Image
        from pathlib import Path

        try:
            input_path = Path(input_path)

            # 1. ì…ë ¥ íŒŒì¼ ê²€ì¦
            if not input_path.exists():
                return False, "íŒŒì¼ì´ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤", None

            # 2. ì›ë³¸ ì²´í¬ì„¬
            original_hash = SafeConverter._calculate_checksum(input_path)

            # 3. ì„ì‹œ íŒŒì¼ ê²½ë¡œ
            temp_path = input_path.with_suffix(f'.temp.{output_format}')
            output_path = input_path.with_suffix(f'.{output_format}')

            # 4. ì´ë¯¸ì§€ ë³€í™˜
            with Image.open(input_path) as img:
                # ë¦¬ì‚¬ì´ì¦ˆ (í•„ìš” ì‹œ)
                if options.get('max_width') or options.get('max_height'):
                    img = SafeConverter._resize_image(img, options)

                # ë³€í™˜ íŒŒë¼ë¯¸í„° ì„¤ì •
                save_params = {
                    'quality': options.get('quality', 80),
                    'optimize': options.get('optimize', True)
                }

                if output_format == 'webp':
                    save_params['method'] = 6  # ìµœê³  ì••ì¶•
                elif output_format == 'avif':
                    save_params['speed'] = 4    # ê· í˜•

                # ë©”íƒ€ë°ì´í„° ë³´ì¡´
                if options.get('preserve_metadata'):
                    save_params['exif'] = img.info.get('exif', b'')

                # í”„ë¡œê·¸ë ˆì‹œë¸Œ
                if options.get('progressive'):
                    save_params['progressive'] = True

                # ë¬´ì†ì‹¤
                if options.get('lossless'):
                    save_params['lossless'] = True

                # ì„ì‹œ íŒŒì¼ë¡œ ì €ì¥
                img.save(temp_path, output_format.upper(), **save_params)

            # 5. ë³€í™˜ ê²°ê³¼ ê²€ì¦
            if not SafeConverter._verify_conversion(temp_path):
                temp_path.unlink()
                return False, "ë³€í™˜ ê²°ê³¼ ê²€ì¦ ì‹¤íŒ¨", None

            # 6. ë°±ì—… ìƒì„± (ì˜µì…˜)
            if options.get('backup'):
                backup_path = SafeConverter._create_backup(input_path)

            # 7. ì›ë³¸ êµì²´
            if output_path.exists():
                output_path.unlink()  # ê¸°ì¡´ íŒŒì¼ ì‚­ì œ

            shutil.move(str(temp_path), str(output_path))

            # 8. ì„ì‹œ íŒŒì¼ ì •ë¦¬
            if temp_path.exists():
                temp_path.unlink()

            return True, "ë³€í™˜ ì„±ê³µ", output_path

        except Exception as e:
            # ì„ì‹œ íŒŒì¼ ì •ë¦¬
            if temp_path and temp_path.exists():
                temp_path.unlink()

            return False, f"ë³€í™˜ ì˜¤ë¥˜: {str(e)}", None

    @staticmethod
    def _calculate_checksum(file_path):
        """íŒŒì¼ ì²´í¬ì„¬ ê³„ì‚° (SHA-256)"""
        import hashlib

        sha256 = hashlib.sha256()
        with open(file_path, 'rb') as f:
            for chunk in iter(lambda: f.read(4096), b''):
                sha256.update(chunk)
        return sha256.hexdigest()

    @staticmethod
    def _verify_conversion(file_path):
        """ë³€í™˜ ê²°ê³¼ ê²€ì¦"""
        from PIL import Image

        try:
            with Image.open(file_path) as img:
                img.verify()
            return True
        except Exception:
            return False

    @staticmethod
    def _resize_image(img, options):
        """ì´ë¯¸ì§€ ë¦¬ì‚¬ì´ì¦ˆ"""
        max_width = options.get('max_width')
        max_height = options.get('max_height')

        if not max_width and not max_height:
            return img

        width, height = img.size

        # ë¹„ìœ¨ ìœ ì§€í•˜ë©° ë¦¬ì‚¬ì´ì¦ˆ
        if max_width and width > max_width:
            ratio = max_width / width
            new_width = max_width
            new_height = int(height * ratio)
        else:
            new_width, new_height = width, height

        if max_height and new_height > max_height:
            ratio = max_height / new_height
            new_height = max_height
            new_width = int(new_width * ratio)

        if new_width != width or new_height != height:
            img = img.resize((new_width, new_height), Image.LANCZOS)

        return img

    @staticmethod
    def _create_backup(file_path):
        """ì›ë³¸ íŒŒì¼ ë°±ì—…"""
        import shutil
        from datetime import datetime
        from pathlib import Path

        file_path = Path(file_path)
        backup_dir = file_path.parent / f"backup_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        backup_dir.mkdir(parents=True, exist_ok=True)

        backup_path = backup_dir / file_path.name
        shutil.copy2(file_path, backup_path)

        return backup_path
```

### 3. FileScanner í´ë˜ìŠ¤

```python
class FileScanner:
    """íŒŒì¼ ì‹œìŠ¤í…œ ìŠ¤ìº”"""

    # ì‹œìŠ¤í…œ í´ë” (ì œì™¸ ëŒ€ìƒ)
    SYSTEM_FOLDERS = [
        'C:\\Windows',
        'C:\\Program Files',
        'C:\\Program Files (x86)',
        'C:\\System Volume Information',
        'C:\\$Recycle.Bin',
        '/System',
        '/Library',
        '/bin',
        '/sbin',
        '/usr',
        '/var'
    ]

    # ì§€ì› í™•ì¥ì
    SAFE_EXTENSIONS = {
        '.jpg', '.jpeg', '.png', '.bmp', '.tiff', '.tif', '.gif'
    }

    def __init__(self):
        self.found_files = []
        self.progress_callback = None

    def scan_files(self, paths, recursive=False, progress_callback=None):
        """
        íŒŒì¼ ìŠ¤ìº”

        Args:
            paths (list): ìŠ¤ìº”í•  ê²½ë¡œ ë¦¬ìŠ¤íŠ¸
            recursive (bool): í•˜ìœ„ í´ë” í¬í•¨ ì—¬ë¶€
            progress_callback (callable): ì§„í–‰ ì½œë°±

        Returns:
            list: ì•ˆì „í•œ ì´ë¯¸ì§€ íŒŒì¼ ê²½ë¡œ ë¦¬ìŠ¤íŠ¸
        """
        self.found_files = []
        self.progress_callback = progress_callback

        for path in paths:
            path = Path(path)

            if path.is_file():
                if self._is_safe_file(path):
                    self.found_files.append(path)
            elif path.is_dir():
                self._scan_directory(path, recursive)

        return self.found_files

    def scan_computer(self, progress_callback=None):
        """
        ì»´í“¨í„° ì „ì²´ ìŠ¤ìº” (Pro ì „ìš©)

        Args:
            progress_callback (callable): ì§„í–‰ ì½œë°±

        Returns:
            list: ì•ˆì „í•œ ì´ë¯¸ì§€ íŒŒì¼ ê²½ë¡œ ë¦¬ìŠ¤íŠ¸
        """
        import platform

        self.found_files = []
        self.progress_callback = progress_callback

        # ë“œë¼ì´ë¸Œ ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
        if platform.system() == 'Windows':
            import string
            import ctypes

            drives = []
            bitmask = ctypes.windll.kernel32.GetLogicalDrives()
            for letter in string.ascii_uppercase:
                if bitmask & 1:
                    drives.append(f"{letter}:")
                bitmask >>= 1
        else:
            drives = ['/']

        # ê° ë“œë¼ì´ë¸Œ ìŠ¤ìº”
        for drive in drives:
            self._scan_directory(Path(drive), recursive=True)

        return self.found_files

    def _scan_directory(self, directory, recursive):
        """ë””ë ‰í† ë¦¬ ìŠ¤ìº”"""
        try:
            # ì‹œìŠ¤í…œ í´ë” ì œì™¸
            if self._is_system_folder(directory):
                return

            # íŒŒì¼ ëª©ë¡
            items = list(directory.iterdir())

            for item in items:
                if self.progress_callback:
                    self.progress_callback(str(item))

                if item.is_file():
                    if self._is_safe_file(item):
                        self.found_files.append(item)
                elif item.is_dir() and recursive:
                    self._scan_directory(item, recursive)

        except (PermissionError, OSError):
            # ê¶Œí•œ ì—†ëŠ” í´ë” ê±´ë„ˆë›°ê¸°
            pass

    def _is_safe_file(self, file_path):
        """ì•ˆì „í•œ íŒŒì¼ì¸ì§€ ê²€ì‚¬"""
        # í™•ì¥ì í™•ì¸
        if file_path.suffix.lower() not in self.SAFE_EXTENSIONS:
            return False

        # ì½ê¸° ê¶Œí•œ í™•ì¸
        if not os.access(file_path, os.R_OK):
            return False

        # íŒŒì¼ í¬ê¸° í™•ì¸ (0ë°”ì´íŠ¸ ì œì™¸)
        if file_path.stat().st_size == 0:
            return False

        return True

    def _is_system_folder(self, directory):
        """ì‹œìŠ¤í…œ í´ë” ì—¬ë¶€ í™•ì¸"""
        dir_str = str(directory)
        return any(sys_folder in dir_str for sys_folder in self.SYSTEM_FOLDERS)
```

### 4. LogManager í´ë˜ìŠ¤

```python
class LogManager:
    """Excel ë¡œê·¸ ê´€ë¦¬"""

    def __init__(self, log_file_path=None):
        """
        ì´ˆê¸°í™”

        Args:
            log_file_path (str): ë¡œê·¸ íŒŒì¼ ê²½ë¡œ (ì„ íƒ)
        """
        from pathlib import Path
        from datetime import datetime

        if log_file_path:
            self.log_file = Path(log_file_path)
        else:
            # ê¸°ë³¸ ë¡œê·¸ íŒŒì¼ ê²½ë¡œ
            self.log_file = Path.home() / "ì´ë¯¸ì§€ë³€í™˜ê¸°_ë¡œê·¸.xlsx"

        self.current_sheet = datetime.now().strftime('%Y-%m-%d')

    def log_conversion(self, records):
        """
        ë³€í™˜ ë¡œê·¸ ê¸°ë¡

        Args:
            records (list): ë¡œê·¸ ë ˆì½”ë“œ ë¦¬ìŠ¤íŠ¸
                [
                    {
                        'timestamp': datetime,
                        'scope': 'íŒŒì¼/í´ë”/ì „ì²´',
                        'mode': 'ë³€í™˜/ë°±ì—…',
                        'original_file': Path,
                        'converted_file': Path,
                        'original_size': int,
                        'converted_size': int,
                        'compression_ratio': float,
                        'status': 'ì„±ê³µ/ì‹¤íŒ¨',
                        'error_message': str
                    },
                    ...
                ]
        """
        import openpyxl
        from openpyxl.utils import get_column_letter
        from openpyxl.styles import Font, PatternFill, Alignment

        # Excel íŒŒì¼ ë¡œë“œ ë˜ëŠ” ìƒì„±
        if self.log_file.exists():
            wb = openpyxl.load_workbook(self.log_file)
        else:
            wb = openpyxl.Workbook()
            wb.remove(wb.active)  # ê¸°ë³¸ ì‹œíŠ¸ ì‚­ì œ

        # ì˜¤ëŠ˜ ë‚ ì§œ ì‹œíŠ¸ ê°€ì ¸ì˜¤ê¸° ë˜ëŠ” ìƒì„±
        if self.current_sheet in wb.sheetnames:
            ws = wb[self.current_sheet]
        else:
            ws = wb.create_sheet(self.current_sheet)
            self._create_header(ws)

        # ë ˆì½”ë“œ ì¶”ê°€
        for record in records:
            row = ws.max_row + 1

            ws.cell(row, 1, record['timestamp'].strftime('%Y-%m-%d %H:%M:%S'))
            ws.cell(row, 2, record['scope'])
            ws.cell(row, 3, record['mode'])
            ws.cell(row, 4, str(record['original_file']))
            ws.cell(row, 5, str(record['converted_file']))
            ws.cell(row, 6, self._format_size(record['original_size']))
            ws.cell(row, 7, self._format_size(record['converted_size']))
            ws.cell(row, 8, f"{record['compression_ratio']:.1f}%")
            ws.cell(row, 9, record['status'])
            ws.cell(row, 10, record.get('error_message', ''))

            # íŒŒì¼ ë§í¬ ì¶”ê°€ (ë³€í™˜ ì„±ê³µ ì‹œ)
            if record['status'] == 'ì„±ê³µ':
                converted_cell = ws.cell(row, 5)
                converted_cell.hyperlink = str(record['converted_file'])
                converted_cell.font = Font(color="0000FF", underline="single")

        # ì €ì¥
        wb.save(self.log_file)

    def _create_header(self, ws):
        """í—¤ë” ìƒì„±"""
        from openpyxl.styles import Font, PatternFill, Alignment

        headers = [
            'ì¼ì‹œ', 'ë²”ìœ„', 'ë°©ì‹', 'ì›ë³¸ íŒŒì¼', 'ë³€í™˜ íŒŒì¼',
            'ì›ë³¸ í¬ê¸°', 'ë³€í™˜ í¬ê¸°', 'ì••ì¶•ë¥ ', 'ìƒíƒœ', 'ì˜¤ë¥˜ ë©”ì‹œì§€'
        ]

        for col, header in enumerate(headers, 1):
            cell = ws.cell(1, col, header)
            cell.font = Font(bold=True, color="FFFFFF")
            cell.fill = PatternFill(start_color="4472C4", end_color="4472C4", fill_type="solid")
            cell.alignment = Alignment(horizontal="center", vertical="center")

        # ì—´ ë„ˆë¹„ ì¡°ì •
        ws.column_dimensions['A'].width = 20
        ws.column_dimensions['B'].width = 10
        ws.column_dimensions['C'].width = 10
        ws.column_dimensions['D'].width = 50
        ws.column_dimensions['E'].width = 50
        ws.column_dimensions['F'].width = 12
        ws.column_dimensions['G'].width = 12
        ws.column_dimensions['H'].width = 10
        ws.column_dimensions['I'].width = 10
        ws.column_dimensions['J'].width = 30

    @staticmethod
    def _format_size(size_bytes):
        """íŒŒì¼ í¬ê¸° í¬ë§·íŒ…"""
        for unit in ['B', 'KB', 'MB', 'GB']:
            if size_bytes < 1024.0:
                return f"{size_bytes:.1f} {unit}"
            size_bytes /= 1024.0
        return f"{size_bytes:.1f} TB"
```

---

## âš¡ ì„±ëŠ¥ ìµœì í™”

### 1. ë©€í‹°ìŠ¤ë ˆë”©

```python
from concurrent.futures import ThreadPoolExecutor, as_completed
import multiprocessing

class ParallelConverter:
    """ë³‘ë ¬ ë³€í™˜ ì²˜ë¦¬"""

    def __init__(self, max_workers=None):
        if max_workers is None:
            max_workers = min(multiprocessing.cpu_count(), 8)
        self.max_workers = max_workers

    def batch_convert(self, file_paths, output_format, options, progress_callback=None):
        """
        ë³‘ë ¬ ë°°ì¹˜ ë³€í™˜

        Args:
            file_paths (list): íŒŒì¼ ê²½ë¡œ ë¦¬ìŠ¤íŠ¸
            output_format (str): ì¶œë ¥ í˜•ì‹
            options (dict): ë³€í™˜ ì˜µì…˜
            progress_callback (callable): ì§„í–‰ ì½œë°±

        Returns:
            list: ë³€í™˜ ê²°ê³¼ ë¦¬ìŠ¤íŠ¸
        """
        results = []
        total = len(file_paths)
        completed = 0

        with ThreadPoolExecutor(max_workers=self.max_workers) as executor:
            # ì‘ì—… ì œì¶œ
            future_to_path = {
                executor.submit(SafeConverter.atomic_convert, path, output_format, options): path
                for path in file_paths
            }

            # ê²°ê³¼ ìˆ˜ì§‘
            for future in as_completed(future_to_path):
                path = future_to_path[future]
                try:
                    result = future.result()
                    results.append(result)
                    completed += 1

                    if progress_callback:
                        progress_callback(completed, total, path)

                except Exception as e:
                    results.append((False, f"ë³€í™˜ ì‹¤íŒ¨: {e}", None))
                    completed += 1

        return results
```

### 2. ë©”ëª¨ë¦¬ ìµœì í™”

```python
def optimize_memory_usage(img):
    """ë©”ëª¨ë¦¬ ì‚¬ìš© ìµœì í™”"""
    # ì´ë¯¸ì§€ ëª¨ë“œ ìµœì í™”
    if img.mode == 'RGBA' and not has_transparency(img):
        img = img.convert('RGB')

    # ëŒ€ìš©ëŸ‰ ì´ë¯¸ì§€ ì²­í¬ ì²˜ë¦¬
    if img.size[0] * img.size[1] > 10000 * 10000:  # 1ì–µ í”½ì…€ ì´ìƒ
        return process_in_chunks(img)

    return img

def has_transparency(img):
    """íˆ¬ëª…ë„ ì±„ë„ í™•ì¸"""
    if img.mode != 'RGBA':
        return False

    alpha = img.split()[-1]
    return alpha.getextrema()[0] < 255
```

---

## ğŸ§ª í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤

### ë‹¨ìœ„ í…ŒìŠ¤íŠ¸

```python
import unittest
from pathlib import Path

class TestImageConverter(unittest.TestCase):

    def setUp(self):
        self.converter = ImageConverter()
        self.test_image = Path('tests/fixtures/test_image.jpg')

    def test_convert_to_webp(self):
        """WebP ë³€í™˜ í…ŒìŠ¤íŠ¸"""
        success, message, output = self.converter.convert(
            self.test_image,
            output_format='webp'
        )

        self.assertTrue(success)
        self.assertTrue(output.exists())
        self.assertEqual(output.suffix, '.webp')

    def test_convert_to_avif(self):
        """AVIF ë³€í™˜ í…ŒìŠ¤íŠ¸"""
        success, message, output = self.converter.convert(
            self.test_image,
            output_format='avif'
        )

        self.assertTrue(success)
        self.assertTrue(output.exists())
        self.assertEqual(output.suffix, '.avif')

    def test_quality_settings(self):
        """í’ˆì§ˆ ì„¤ì • í…ŒìŠ¤íŠ¸"""
        options = {'quality': 90}
        success, message, output = self.converter.convert(
            self.test_image,
            options=options
        )

        self.assertTrue(success)

    def test_backup_mode(self):
        """ë°±ì—… ëª¨ë“œ í…ŒìŠ¤íŠ¸"""
        options = {'backup': True}
        success, message, output = self.converter.convert(
            self.test_image,
            options=options
        )

        self.assertTrue(success)
        # ë°±ì—… í´ë” ì¡´ì¬ í™•ì¸
        backup_folder = self.test_image.parent / 'backup_*'
        self.assertTrue(any(self.test_image.parent.glob('backup_*')))

    def test_invalid_file(self):
        """ìœ íš¨í•˜ì§€ ì•Šì€ íŒŒì¼ í…ŒìŠ¤íŠ¸"""
        invalid_file = Path('tests/fixtures/invalid.txt')
        success, message, output = self.converter.convert(invalid_file)

        self.assertFalse(success)

    def test_system_folder_exclusion(self):
        """ì‹œìŠ¤í…œ í´ë” ì œì™¸ í…ŒìŠ¤íŠ¸"""
        scanner = FileScanner()
        system_folder = Path('C:\\Windows')

        self.assertTrue(scanner._is_system_folder(system_folder))
```

---

## ğŸ“Š ì„±ëŠ¥ ì§€í‘œ

### ëª©í‘œ ì„±ëŠ¥
- **ë³€í™˜ ì†ë„**: 1MB ì´ë¯¸ì§€ ê¸°ì¤€ < 1ì´ˆ
- **ë©”ëª¨ë¦¬ ì‚¬ìš©**: ì´ë¯¸ì§€ë‹¹ ìµœëŒ€ 50MB
- **CPU ì‚¬ìš©ë¥ **: ë©€í‹°ì½”ì–´ í™œìš© 80% ì´ìƒ
- **ë°°ì¹˜ ì²˜ë¦¬**: 100ê°œ íŒŒì¼ < 2ë¶„

### ìµœì í™” ê¸°ë²•
- ë©€í‹°ìŠ¤ë ˆë”© (ThreadPoolExecutor)
- ì²­í¬ ë‹¨ìœ„ ì²˜ë¦¬ (ëŒ€ìš©ëŸ‰ ì´ë¯¸ì§€)
- ë©”ëª¨ë¦¬ í’€ë§ (ì´ë¯¸ì§€ ê°ì²´ ì¬ì‚¬ìš©)
- ì ì§„ì  ë¡œë”© (í•„ìš”í•œ ë¶€ë¶„ë§Œ)

---

> **ì°¸ì¡° ë¬¸ì„œ**
> - [ì´ë¯¸ì§€ë³€í™˜ê¸°_ê¸°íšì„œ.md](../ì´ë¯¸ì§€ë³€í™˜ê¸°_ê¸°íšì„œ.md)
> - [ui_ì„¤ê³„.md](./ui_ì„¤ê³„.md)
> - [task.md](../task.md)
