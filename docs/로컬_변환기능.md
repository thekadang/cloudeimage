# 로컬 변환 기능 설계

> **목적**: 안전하고 효율적인 이미지 변환 엔진 구현
> **핵심 원칙**: 안전성, 성능, 사용자 편의성
> **최종 업데이트**: 2025-10-23

---

## 🎯 핵심 기능 요구사항

### 1. 지원 이미지 형식

#### 입력 형식 (Source)
- **JPEG/JPG**: `.jpg`, `.jpeg`
- **PNG**: `.png`
- **BMP**: `.bmp`
- **TIFF**: `.tiff`, `.tif`
- **GIF**: `.gif` (정적 이미지만, 애니메이션 미지원)

#### 출력 형식 (Target)
- **WebP**: `.webp` (모든 플랜)
- **AVIF**: `.avif` (Basic 이상)

### 2. 변환 옵션

| 옵션 | 설명 | 기본값 | 범위 |
|------|------|--------|------|
| **품질 (Quality)** | 압축 품질 설정 | 80 | 50-100 |
| **최적화 (Optimize)** | 추가 최적화 적용 | True | True/False |
| **프로그레시브 (Progressive)** | 점진적 로딩 지원 | True | True/False |
| **메타데이터 보존** | EXIF 정보 유지 | False | True/False |
| **최대 너비** | 리사이즈 최대 너비 | 1920px | 제한 없음 |
| **최대 높이** | 리사이즈 최대 높이 | 1080px | 제한 없음 |
| **무손실 (Lossless)** | 무손실 압축 | False | True/False |

---

## 🏗️ 변환 엔진 아키텍처

### 클래스 다이어그램

```python
ImageConverter (메인 클래스)
  ├── SafeConverter (안전한 변환 처리)
  ├── FormatDetector (형식 감지)
  ├── QualityOptimizer (품질 최적화)
  ├── MetadataHandler (메타데이터 처리)
  └── ErrorRecovery (에러 복구)

FileScanner (파일 스캔)
  ├── SystemFolderFilter (시스템 폴더 제외)
  ├── SafetyChecker (안전성 검사)
  └── ProgressTracker (진행 추적)

LogManager (로그 관리)
  ├── ExcelLogger (Excel 로그)
  ├── FileLinker (파일 링크)
  └── SheetManager (시트 관리)
```

---

## 💻 핵심 모듈 상세 설계

### 1. ImageConverter 클래스

```python
class ImageConverter:
    """이미지 변환 엔진 메인 클래스"""

    def __init__(self, config=None):
        """
        초기화

        Args:
            config (dict): 변환 설정 (선택)
        """
        self.config = config or self._get_default_config()
        self.subscription_manager = SubscriptionManager()
        self.daily_usage = 0
        self.user_limits = {}

    def convert(self, input_path, output_format='webp', options=None):
        """
        단일 이미지 변환

        Args:
            input_path (str/Path): 입력 파일 경로
            output_format (str): 출력 형식 ('webp' or 'avif')
            options (dict): 변환 옵션

        Returns:
            tuple: (성공 여부, 결과 메시지, 출력 경로)
        """
        pass

    def batch_convert(self, file_paths, output_format='webp', options=None):
        """
        배치 변환 (멀티스레딩)

        Args:
            file_paths (list): 입력 파일 경로 리스트
            output_format (str): 출력 형식
            options (dict): 변환 옵션

        Returns:
            list: [(성공 여부, 메시지, 출력 경로), ...]
        """
        pass

    def _safe_convert(self, input_path, output_path, options):
        """
        안전한 변환 (원자적 처리)

        Process:
        1. 원본 파일 체크섬 계산
        2. 임시 파일로 변환
        3. 변환 결과 검증
        4. 성공 시 원본 교체
        5. 실패 시 임시 파일 삭제
        """
        pass

    def _get_default_config(self):
        """기본 설정 반환"""
        return {
            'quality': 80,
            'optimize': True,
            'progressive': True,
            'preserve_metadata': False,
            'max_width': 1920,
            'max_height': 1080,
            'lossless': False,
            'backup': False
        }
```

### 2. SafeConverter 클래스

```python
class SafeConverter:
    """안전한 변환 처리 (원자적 변환)"""

    @staticmethod
    def atomic_convert(input_path, output_format, options):
        """
        원자적 변환 프로세스

        Steps:
        1. 입력 파일 검증
        2. 체크섬 계산 (SHA-256)
        3. 임시 파일로 변환
        4. 변환 결과 검증
        5. 백업 생성 (옵션)
        6. 원본 교체
        7. 임시 파일 정리

        Args:
            input_path (Path): 입력 파일
            output_format (str): 출력 형식
            options (dict): 변환 옵션

        Returns:
            tuple: (성공, 메시지, 출력 경로)
        """
        import hashlib
        import shutil
        from PIL import Image
        from pathlib import Path

        try:
            input_path = Path(input_path)

            # 1. 입력 파일 검증
            if not input_path.exists():
                return False, "파일이 존재하지 않습니다", None

            # 2. 원본 체크섬
            original_hash = SafeConverter._calculate_checksum(input_path)

            # 3. 임시 파일 경로
            temp_path = input_path.with_suffix(f'.temp.{output_format}')
            output_path = input_path.with_suffix(f'.{output_format}')

            # 4. 이미지 변환
            with Image.open(input_path) as img:
                # 리사이즈 (필요 시)
                if options.get('max_width') or options.get('max_height'):
                    img = SafeConverter._resize_image(img, options)

                # 변환 파라미터 설정
                save_params = {
                    'quality': options.get('quality', 80),
                    'optimize': options.get('optimize', True)
                }

                if output_format == 'webp':
                    save_params['method'] = 6  # 최고 압축
                elif output_format == 'avif':
                    save_params['speed'] = 4    # 균형

                # 메타데이터 보존
                if options.get('preserve_metadata'):
                    save_params['exif'] = img.info.get('exif', b'')

                # 프로그레시브
                if options.get('progressive'):
                    save_params['progressive'] = True

                # 무손실
                if options.get('lossless'):
                    save_params['lossless'] = True

                # 임시 파일로 저장
                img.save(temp_path, output_format.upper(), **save_params)

            # 5. 변환 결과 검증
            if not SafeConverter._verify_conversion(temp_path):
                temp_path.unlink()
                return False, "변환 결과 검증 실패", None

            # 6. 백업 생성 (옵션)
            if options.get('backup'):
                backup_path = SafeConverter._create_backup(input_path)

            # 7. 원본 교체
            if output_path.exists():
                output_path.unlink()  # 기존 파일 삭제

            shutil.move(str(temp_path), str(output_path))

            # 8. 임시 파일 정리
            if temp_path.exists():
                temp_path.unlink()

            return True, "변환 성공", output_path

        except Exception as e:
            # 임시 파일 정리
            if temp_path and temp_path.exists():
                temp_path.unlink()

            return False, f"변환 오류: {str(e)}", None

    @staticmethod
    def _calculate_checksum(file_path):
        """파일 체크섬 계산 (SHA-256)"""
        import hashlib

        sha256 = hashlib.sha256()
        with open(file_path, 'rb') as f:
            for chunk in iter(lambda: f.read(4096), b''):
                sha256.update(chunk)
        return sha256.hexdigest()

    @staticmethod
    def _verify_conversion(file_path):
        """변환 결과 검증"""
        from PIL import Image

        try:
            with Image.open(file_path) as img:
                img.verify()
            return True
        except Exception:
            return False

    @staticmethod
    def _resize_image(img, options):
        """이미지 리사이즈"""
        max_width = options.get('max_width')
        max_height = options.get('max_height')

        if not max_width and not max_height:
            return img

        width, height = img.size

        # 비율 유지하며 리사이즈
        if max_width and width > max_width:
            ratio = max_width / width
            new_width = max_width
            new_height = int(height * ratio)
        else:
            new_width, new_height = width, height

        if max_height and new_height > max_height:
            ratio = max_height / new_height
            new_height = max_height
            new_width = int(new_width * ratio)

        if new_width != width or new_height != height:
            img = img.resize((new_width, new_height), Image.LANCZOS)

        return img

    @staticmethod
    def _create_backup(file_path):
        """원본 파일 백업"""
        import shutil
        from datetime import datetime
        from pathlib import Path

        file_path = Path(file_path)
        backup_dir = file_path.parent / f"backup_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        backup_dir.mkdir(parents=True, exist_ok=True)

        backup_path = backup_dir / file_path.name
        shutil.copy2(file_path, backup_path)

        return backup_path
```

### 3. FileScanner 클래스

```python
class FileScanner:
    """파일 시스템 스캔"""

    # 시스템 폴더 (제외 대상)
    SYSTEM_FOLDERS = [
        'C:\\Windows',
        'C:\\Program Files',
        'C:\\Program Files (x86)',
        'C:\\System Volume Information',
        'C:\\$Recycle.Bin',
        '/System',
        '/Library',
        '/bin',
        '/sbin',
        '/usr',
        '/var'
    ]

    # 지원 확장자
    SAFE_EXTENSIONS = {
        '.jpg', '.jpeg', '.png', '.bmp', '.tiff', '.tif', '.gif'
    }

    def __init__(self):
        self.found_files = []
        self.progress_callback = None

    def scan_files(self, paths, recursive=False, progress_callback=None):
        """
        파일 스캔

        Args:
            paths (list): 스캔할 경로 리스트
            recursive (bool): 하위 폴더 포함 여부
            progress_callback (callable): 진행 콜백

        Returns:
            list: 안전한 이미지 파일 경로 리스트
        """
        self.found_files = []
        self.progress_callback = progress_callback

        for path in paths:
            path = Path(path)

            if path.is_file():
                if self._is_safe_file(path):
                    self.found_files.append(path)
            elif path.is_dir():
                self._scan_directory(path, recursive)

        return self.found_files

    def scan_computer(self, progress_callback=None):
        """
        컴퓨터 전체 스캔 (Pro 전용)

        Args:
            progress_callback (callable): 진행 콜백

        Returns:
            list: 안전한 이미지 파일 경로 리스트
        """
        import platform

        self.found_files = []
        self.progress_callback = progress_callback

        # 드라이브 목록 가져오기
        if platform.system() == 'Windows':
            import string
            import ctypes

            drives = []
            bitmask = ctypes.windll.kernel32.GetLogicalDrives()
            for letter in string.ascii_uppercase:
                if bitmask & 1:
                    drives.append(f"{letter}:")
                bitmask >>= 1
        else:
            drives = ['/']

        # 각 드라이브 스캔
        for drive in drives:
            self._scan_directory(Path(drive), recursive=True)

        return self.found_files

    def _scan_directory(self, directory, recursive):
        """디렉토리 스캔"""
        try:
            # 시스템 폴더 제외
            if self._is_system_folder(directory):
                return

            # 파일 목록
            items = list(directory.iterdir())

            for item in items:
                if self.progress_callback:
                    self.progress_callback(str(item))

                if item.is_file():
                    if self._is_safe_file(item):
                        self.found_files.append(item)
                elif item.is_dir() and recursive:
                    self._scan_directory(item, recursive)

        except (PermissionError, OSError):
            # 권한 없는 폴더 건너뛰기
            pass

    def _is_safe_file(self, file_path):
        """안전한 파일인지 검사"""
        # 확장자 확인
        if file_path.suffix.lower() not in self.SAFE_EXTENSIONS:
            return False

        # 읽기 권한 확인
        if not os.access(file_path, os.R_OK):
            return False

        # 파일 크기 확인 (0바이트 제외)
        if file_path.stat().st_size == 0:
            return False

        return True

    def _is_system_folder(self, directory):
        """시스템 폴더 여부 확인"""
        dir_str = str(directory)
        return any(sys_folder in dir_str for sys_folder in self.SYSTEM_FOLDERS)
```

### 4. LogManager 클래스

```python
class LogManager:
    """Excel 로그 관리"""

    def __init__(self, log_file_path=None):
        """
        초기화

        Args:
            log_file_path (str): 로그 파일 경로 (선택)
        """
        from pathlib import Path
        from datetime import datetime

        if log_file_path:
            self.log_file = Path(log_file_path)
        else:
            # 기본 로그 파일 경로
            self.log_file = Path.home() / "이미지변환기_로그.xlsx"

        self.current_sheet = datetime.now().strftime('%Y-%m-%d')

    def log_conversion(self, records):
        """
        변환 로그 기록

        Args:
            records (list): 로그 레코드 리스트
                [
                    {
                        'timestamp': datetime,
                        'scope': '파일/폴더/전체',
                        'mode': '변환/백업',
                        'original_file': Path,
                        'converted_file': Path,
                        'original_size': int,
                        'converted_size': int,
                        'compression_ratio': float,
                        'status': '성공/실패',
                        'error_message': str
                    },
                    ...
                ]
        """
        import openpyxl
        from openpyxl.utils import get_column_letter
        from openpyxl.styles import Font, PatternFill, Alignment

        # Excel 파일 로드 또는 생성
        if self.log_file.exists():
            wb = openpyxl.load_workbook(self.log_file)
        else:
            wb = openpyxl.Workbook()
            wb.remove(wb.active)  # 기본 시트 삭제

        # 오늘 날짜 시트 가져오기 또는 생성
        if self.current_sheet in wb.sheetnames:
            ws = wb[self.current_sheet]
        else:
            ws = wb.create_sheet(self.current_sheet)
            self._create_header(ws)

        # 레코드 추가
        for record in records:
            row = ws.max_row + 1

            ws.cell(row, 1, record['timestamp'].strftime('%Y-%m-%d %H:%M:%S'))
            ws.cell(row, 2, record['scope'])
            ws.cell(row, 3, record['mode'])
            ws.cell(row, 4, str(record['original_file']))
            ws.cell(row, 5, str(record['converted_file']))
            ws.cell(row, 6, self._format_size(record['original_size']))
            ws.cell(row, 7, self._format_size(record['converted_size']))
            ws.cell(row, 8, f"{record['compression_ratio']:.1f}%")
            ws.cell(row, 9, record['status'])
            ws.cell(row, 10, record.get('error_message', ''))

            # 파일 링크 추가 (변환 성공 시)
            if record['status'] == '성공':
                converted_cell = ws.cell(row, 5)
                converted_cell.hyperlink = str(record['converted_file'])
                converted_cell.font = Font(color="0000FF", underline="single")

        # 저장
        wb.save(self.log_file)

    def _create_header(self, ws):
        """헤더 생성"""
        from openpyxl.styles import Font, PatternFill, Alignment

        headers = [
            '일시', '범위', '방식', '원본 파일', '변환 파일',
            '원본 크기', '변환 크기', '압축률', '상태', '오류 메시지'
        ]

        for col, header in enumerate(headers, 1):
            cell = ws.cell(1, col, header)
            cell.font = Font(bold=True, color="FFFFFF")
            cell.fill = PatternFill(start_color="4472C4", end_color="4472C4", fill_type="solid")
            cell.alignment = Alignment(horizontal="center", vertical="center")

        # 열 너비 조정
        ws.column_dimensions['A'].width = 20
        ws.column_dimensions['B'].width = 10
        ws.column_dimensions['C'].width = 10
        ws.column_dimensions['D'].width = 50
        ws.column_dimensions['E'].width = 50
        ws.column_dimensions['F'].width = 12
        ws.column_dimensions['G'].width = 12
        ws.column_dimensions['H'].width = 10
        ws.column_dimensions['I'].width = 10
        ws.column_dimensions['J'].width = 30

    @staticmethod
    def _format_size(size_bytes):
        """파일 크기 포맷팅"""
        for unit in ['B', 'KB', 'MB', 'GB']:
            if size_bytes < 1024.0:
                return f"{size_bytes:.1f} {unit}"
            size_bytes /= 1024.0
        return f"{size_bytes:.1f} TB"
```

---

## ⚡ 성능 최적화

### 1. 멀티스레딩

```python
from concurrent.futures import ThreadPoolExecutor, as_completed
import multiprocessing

class ParallelConverter:
    """병렬 변환 처리"""

    def __init__(self, max_workers=None):
        if max_workers is None:
            max_workers = min(multiprocessing.cpu_count(), 8)
        self.max_workers = max_workers

    def batch_convert(self, file_paths, output_format, options, progress_callback=None):
        """
        병렬 배치 변환

        Args:
            file_paths (list): 파일 경로 리스트
            output_format (str): 출력 형식
            options (dict): 변환 옵션
            progress_callback (callable): 진행 콜백

        Returns:
            list: 변환 결과 리스트
        """
        results = []
        total = len(file_paths)
        completed = 0

        with ThreadPoolExecutor(max_workers=self.max_workers) as executor:
            # 작업 제출
            future_to_path = {
                executor.submit(SafeConverter.atomic_convert, path, output_format, options): path
                for path in file_paths
            }

            # 결과 수집
            for future in as_completed(future_to_path):
                path = future_to_path[future]
                try:
                    result = future.result()
                    results.append(result)
                    completed += 1

                    if progress_callback:
                        progress_callback(completed, total, path)

                except Exception as e:
                    results.append((False, f"변환 실패: {e}", None))
                    completed += 1

        return results
```

### 2. 메모리 최적화

```python
def optimize_memory_usage(img):
    """메모리 사용 최적화"""
    # 이미지 모드 최적화
    if img.mode == 'RGBA' and not has_transparency(img):
        img = img.convert('RGB')

    # 대용량 이미지 청크 처리
    if img.size[0] * img.size[1] > 10000 * 10000:  # 1억 픽셀 이상
        return process_in_chunks(img)

    return img

def has_transparency(img):
    """투명도 채널 확인"""
    if img.mode != 'RGBA':
        return False

    alpha = img.split()[-1]
    return alpha.getextrema()[0] < 255
```

---

## 🧪 테스트 케이스

### 단위 테스트

```python
import unittest
from pathlib import Path

class TestImageConverter(unittest.TestCase):

    def setUp(self):
        self.converter = ImageConverter()
        self.test_image = Path('tests/fixtures/test_image.jpg')

    def test_convert_to_webp(self):
        """WebP 변환 테스트"""
        success, message, output = self.converter.convert(
            self.test_image,
            output_format='webp'
        )

        self.assertTrue(success)
        self.assertTrue(output.exists())
        self.assertEqual(output.suffix, '.webp')

    def test_convert_to_avif(self):
        """AVIF 변환 테스트"""
        success, message, output = self.converter.convert(
            self.test_image,
            output_format='avif'
        )

        self.assertTrue(success)
        self.assertTrue(output.exists())
        self.assertEqual(output.suffix, '.avif')

    def test_quality_settings(self):
        """품질 설정 테스트"""
        options = {'quality': 90}
        success, message, output = self.converter.convert(
            self.test_image,
            options=options
        )

        self.assertTrue(success)

    def test_backup_mode(self):
        """백업 모드 테스트"""
        options = {'backup': True}
        success, message, output = self.converter.convert(
            self.test_image,
            options=options
        )

        self.assertTrue(success)
        # 백업 폴더 존재 확인
        backup_folder = self.test_image.parent / 'backup_*'
        self.assertTrue(any(self.test_image.parent.glob('backup_*')))

    def test_invalid_file(self):
        """유효하지 않은 파일 테스트"""
        invalid_file = Path('tests/fixtures/invalid.txt')
        success, message, output = self.converter.convert(invalid_file)

        self.assertFalse(success)

    def test_system_folder_exclusion(self):
        """시스템 폴더 제외 테스트"""
        scanner = FileScanner()
        system_folder = Path('C:\\Windows')

        self.assertTrue(scanner._is_system_folder(system_folder))
```

---

## 📊 성능 지표

### 목표 성능
- **변환 속도**: 1MB 이미지 기준 < 1초
- **메모리 사용**: 이미지당 최대 50MB
- **CPU 사용률**: 멀티코어 활용 80% 이상
- **배치 처리**: 100개 파일 < 2분

### 최적화 기법
- 멀티스레딩 (ThreadPoolExecutor)
- 청크 단위 처리 (대용량 이미지)
- 메모리 풀링 (이미지 객체 재사용)
- 점진적 로딩 (필요한 부분만)

---

> **참조 문서**
> - [이미지변환기_기획서.md](../이미지변환기_기획서.md)
> - [ui_설계.md](./ui_설계.md)
> - [task.md](../task.md)
