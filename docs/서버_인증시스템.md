# 서버 인증 시스템 설계

> **목적**: 안전하고 효율적인 하이브리드 인증 시스템 구현
> **핵심 원칙**: 보안성, 사용자 편의성, 비용 효율성
> **최종 업데이트**: 2025-10-23
> **관련 폴더**: `src/auth/`

## 📁 관련 코드 위치

이 문서는 다음 폴더의 구현 가이드입니다:
- **src/auth/subscription.py** - SubscriptionManager 클래스, 구독 상태 관리
- **src/auth/security.py** - JWT 검증, 하드웨어 ID 생성, 암호화
- **src/auth/api_client.py** - AWS API 통신, 토큰 관리

**규칙**:
- 인증 시스템 개발 시 하이브리드 인증 플로우를 반드시 따르세요
- 7일 온라인 체크, 30일 오프라인 유예 정책 준수
- 코드 변경 시 이 문서도 함께 업데이트하세요

---

## 🎯 인증 시스템 개요

### 하이브리드 인증 방식

**온라인 인증** + **오프라인 유예**를 결합한 방식으로, 사용자 편의성과 비용 효율성을 동시에 달성합니다.

| 구분 | 온라인 인증 | 오프라인 유예 |
|------|-----------|-------------|
| **주기** | 7일마다 | 최대 30일 |
| **서버 호출** | Yes | No (로컬 캐시) |
| **네트워크 필요** | Yes | No |
| **비용** | API 호출 비용 | 0원 |
| **보안** | 높음 | 중간 |

### 인증 플로우

```
앱 시작
  ↓
로컬 캐시 확인
  ↓
캐시 있음? ─── No ──→ 온라인 인증 필수
  │
 Yes
  ↓
캐시 유효? (7일 이내)
  │
 Yes ──→ 로컬 인증 성공
  │
 No
  ↓
네트워크 연결?
  │
 Yes ──→ 온라인 인증
  │
 No
  ↓
오프라인 유예 (30일) 체크
  │
유효? ─── Yes ──→ 오프라인 모드
  │
 No
  ↓
인증 실패 (재로그인 필요)
```

---

## 🔐 보안 아키텍처

### JWT 토큰 구조

```json
{
  "header": {
    "alg": "RS256",
    "typ": "JWT"
  },
  "payload": {
    "user_id": "user_12345",
    "email": "user@example.com",
    "plan": "pro",
    "hardware_id": "abc123def456",
    "exp": 1735689600,  // 만료 시간 (7일 후)
    "iat": 1735084800   // 발급 시간
  },
  "signature": "..."
}
```

### 하드웨어 ID 생성

```python
import hashlib
import platform
import uuid

def generate_hardware_id():
    """
    하드웨어 고유 ID 생성

    조합 요소:
    - MAC 주소
    - CPU 정보
    - 머신 정보

    Returns:
        str: 16자리 하드웨어 ID
    """
    # MAC 주소
    mac_address = ':'.join([
        '{:02x}'.format((uuid.getnode() >> i) & 0xff)
        for i in range(0, 8*6, 8)
    ][::-1])

    # CPU 및 머신 정보
    machine_info = f"{platform.machine()}-{platform.processor()}"

    # SHA-256 해시
    combined = f"{machine_info}-{mac_address}"
    hardware_hash = hashlib.sha256(combined.encode()).hexdigest()

    return hardware_hash[:16]  # 앞 16자리만 사용
```

---

## 💻 클라이언트 인증 모듈

### SubscriptionManager 클래스

```python
import requests
import json
import jwt
import keyring
from datetime import datetime, timedelta
from pathlib import Path

class SubscriptionManager:
    """구독 관리 클래스"""

    def __init__(self, api_base_url="https://api.imageconverter.com"):
        self.api_base = api_base_url
        self.token_cache_file = Path.home() / ".imageconverter" / "auth.cache"
        self.hardware_id = generate_hardware_id()
        self.token_cache_file.parent.mkdir(parents=True, exist_ok=True)

    def login(self, email, password):
        """
        로그인 및 토큰 발급

        Args:
            email (str): 사용자 이메일
            password (str): 비밀번호

        Returns:
            tuple: (성공 여부, 메시지)
        """
        try:
            response = requests.post(
                f"{self.api_base}/auth/login",
                json={
                    "email": email,
                    "password": password,
                    "hardware_id": self.hardware_id,
                    "client_version": "1.0.0"
                },
                timeout=10
            )

            if response.status_code == 200:
                data = response.json()
                access_token = data['access_token']
                refresh_token = data['refresh_token']

                # 토큰 안전 저장 (keyring)
                keyring.set_password("imageconverter", "access_token", access_token)
                keyring.set_password("imageconverter", "refresh_token", refresh_token)

                # 로컬 캐시 저장
                self._save_token_cache(data)

                return True, "로그인 성공"
            else:
                error_msg = response.json().get('message', '로그인 실패')
                return False, error_msg

        except requests.RequestException as e:
            return False, f"네트워크 오류: {e}"

    def check_subscription(self):
        """
        구독 상태 확인

        Returns:
            tuple: (성공 여부, 메시지, 구독 데이터)
        """
        # 1. 로컬 캐시 확인
        cache_valid, cache_data = self._check_local_cache()

        if cache_valid:
            return True, "로컬 인증 성공", cache_data

        # 2. 온라인 인증 시도
        token = keyring.get_password("imageconverter", "access_token")

        if not token:
            return False, "로그인이 필요합니다", {}

        try:
            headers = {"Authorization": f"Bearer {token}"}
            response = requests.get(
                f"{self.api_base}/subscription/status",
                headers=headers,
                timeout=10
            )

            if response.status_code == 200:
                data = response.json()

                # 로컬 캐시 업데이트
                self._save_token_cache(data)

                return True, "온라인 인증 성공", data

            elif response.status_code == 401:
                # 토큰 갱신 시도
                if self._refresh_token():
                    return self.check_subscription()  # 재귀 호출
                else:
                    return False, "인증 만료 (재로그인 필요)", {}

            else:
                return False, "구독 확인 실패", {}

        except requests.RequestException:
            # 3. 오프라인 모드 (네트워크 오류 시)
            return self._check_offline_subscription()

    def _check_local_cache(self):
        """
        로컬 캐시 확인 (7일 이내)

        Returns:
            tuple: (유효 여부, 캐시 데이터)
        """
        try:
            if not self.token_cache_file.exists():
                return False, {}

            with open(self.token_cache_file, 'r') as f:
                cache_data = json.load(f)

            last_check = datetime.fromisoformat(cache_data['last_check'])

            # 7일 이내면 유효
            if datetime.now() - last_check < timedelta(days=7):
                return True, cache_data['subscription']
            else:
                return False, {}

        except (json.JSONDecodeError, KeyError, ValueError):
            return False, {}

    def _check_offline_subscription(self):
        """
        오프라인 구독 확인 (30일 유예)

        Returns:
            tuple: (성공 여부, 메시지, 구독 데이터)
        """
        try:
            if not self.token_cache_file.exists():
                return False, "초기 온라인 인증이 필요합니다", {}

            with open(self.token_cache_file, 'r') as f:
                cache_data = json.load(f)

            last_check = datetime.fromisoformat(cache_data['last_check'])

            # 30일 이내면 오프라인 모드 허용
            if datetime.now() - last_check < timedelta(days=30):
                days_left = 30 - (datetime.now() - last_check).days
                return True, f"오프라인 모드 ({days_left}일 남음)", cache_data['subscription']
            else:
                return False, "온라인 인증이 필요합니다 (30일 초과)", {}

        except (json.JSONDecodeError, KeyError, ValueError):
            return False, "캐시 데이터 오류", {}

    def _refresh_token(self):
        """
        토큰 갱신

        Returns:
            bool: 갱신 성공 여부
        """
        refresh_token = keyring.get_password("imageconverter", "refresh_token")

        if not refresh_token:
            return False

        try:
            response = requests.post(
                f"{self.api_base}/auth/refresh",
                json={"refresh_token": refresh_token},
                timeout=10
            )

            if response.status_code == 200:
                data = response.json()
                new_token = data['access_token']

                # 새 토큰 저장
                keyring.set_password("imageconverter", "access_token", new_token)

                return True

        except requests.RequestException:
            pass

        return False

    def _save_token_cache(self, data):
        """
        토큰 캐시 저장

        Args:
            data (dict): API 응답 데이터
        """
        cache_data = {
            'last_check': datetime.now().isoformat(),
            'subscription': {
                'plan': data.get('plan', 'free'),
                'expiry_date': data.get('expiry_date'),
                'daily_conversions': data.get('daily_conversions', 5)
            }
        }

        with open(self.token_cache_file, 'w') as f:
            json.dump(cache_data, f)

    def get_user_limits(self, subscription_data):
        """
        구독 등급별 사용 제한 반환

        Args:
            subscription_data (dict): 구독 정보

        Returns:
            dict: 사용 제한 정보
        """
        plan = subscription_data.get('plan', 'free')

        limits = {
            'free': {
                'daily_conversions': 5,
                'formats': ['webp'],
                'features': ['individual_files'],
                'batch_size': 1
            },
            'basic': {
                'daily_conversions': 50,
                'formats': ['webp', 'avif'],
                'features': ['individual_files', 'folder_conversion', 'scheduling'],
                'batch_size': 10
            },
            'pro': {
                'daily_conversions': -1,  # 무제한
                'formats': ['webp', 'avif'],
                'features': ['all'],
                'batch_size': 100
            }
        }

        return limits.get(plan, limits['free'])

    def logout(self):
        """로그아웃 (토큰 삭제)"""
        try:
            keyring.delete_password("imageconverter", "access_token")
            keyring.delete_password("imageconverter", "refresh_token")

            if self.token_cache_file.exists():
                self.token_cache_file.unlink()

            return True, "로그아웃 성공"

        except Exception as e:
            return False, f"로그아웃 오류: {e}"
```

---

## 🌐 서버 인증 API (AWS Lambda)

### 1. 로그인 API

```python
# handlers/auth.py

import json
import jwt
import boto3
import hashlib
from datetime import datetime, timedelta

SECRET_KEY = os.getenv('JWT_SECRET_KEY')
ALGORITHM = 'RS256'

dynamodb = boto3.resource('dynamodb')
users_table = dynamodb.Table('users')

def authenticate(event, context):
    """
    사용자 로그인

    Request Body:
        {
            "email": "user@example.com",
            "password": "password123",
            "hardware_id": "abc123def456",
            "client_version": "1.0.0"
        }

    Response:
        {
            "access_token": "...",
            "refresh_token": "...",
            "plan": "pro",
            "expiry_date": "2025-11-23"
        }
    """
    try:
        body = json.loads(event['body'])
        email = body['email']
        password = body['password']
        hardware_id = body['hardware_id']

        # 1. 사용자 확인
        response = users_table.get_item(Key={'email': email})

        if 'Item' not in response:
            return {
                'statusCode': 401,
                'body': json.dumps({'message': '이메일 또는 비밀번호가 잘못되었습니다'})
            }

        user = response['Item']

        # 2. 비밀번호 확인
        password_hash = hashlib.sha256(password.encode()).hexdigest()

        if user['password_hash'] != password_hash:
            return {
                'statusCode': 401,
                'body': json.dumps({'message': '이메일 또는 비밀번호가 잘못되었습니다'})
            }

        # 3. 하드웨어 ID 확인/업데이트
        if 'hardware_id' in user and user['hardware_id'] != hardware_id:
            # 기기 변경 확인 (Pro 플랜은 허용, Free/Basic은 제한)
            if user['plan'] in ['free', 'basic']:
                return {
                    'statusCode': 403,
                    'body': json.dumps({'message': '다른 기기에서 이미 사용 중입니다'})
                }

        # 4. JWT 토큰 생성
        access_token = create_access_token(user, hardware_id)
        refresh_token = create_refresh_token(user)

        # 5. 하드웨어 ID 저장
        users_table.update_item(
            Key={'email': email},
            UpdateExpression='SET hardware_id = :hw, last_login = :now',
            ExpressionAttributeValues={
                ':hw': hardware_id,
                ':now': datetime.now().isoformat()
            }
        )

        return {
            'statusCode': 200,
            'body': json.dumps({
                'access_token': access_token,
                'refresh_token': refresh_token,
                'plan': user['plan'],
                'expiry_date': user.get('expiry_date'),
                'daily_conversions': get_daily_limit(user['plan'])
            })
        }

    except Exception as e:
        return {
            'statusCode': 500,
            'body': json.dumps({'message': f'서버 오류: {str(e)}'})
        }

def create_access_token(user, hardware_id):
    """Access Token 생성 (7일 유효)"""
    payload = {
        'user_id': user['user_id'],
        'email': user['email'],
        'plan': user['plan'],
        'hardware_id': hardware_id,
        'exp': datetime.utcnow() + timedelta(days=7),
        'iat': datetime.utcnow()
    }

    return jwt.encode(payload, SECRET_KEY, algorithm=ALGORITHM)

def create_refresh_token(user):
    """Refresh Token 생성 (30일 유효)"""
    payload = {
        'user_id': user['user_id'],
        'exp': datetime.utcnow() + timedelta(days=30),
        'iat': datetime.utcnow()
    }

    return jwt.encode(payload, SECRET_KEY, algorithm=ALGORITHM)

def get_daily_limit(plan):
    """플랜별 일일 변환 한도"""
    limits = {
        'free': 5,
        'basic': 50,
        'pro': -1  # 무제한
    }
    return limits.get(plan, 5)
```

### 2. 구독 상태 확인 API

```python
# handlers/subscription.py

import json
import jwt
import boto3
from datetime import datetime

SECRET_KEY = os.getenv('JWT_SECRET_KEY')
ALGORITHM = 'RS256'

dynamodb = boto3.resource('dynamodb')
users_table = dynamodb.Table('users')

def check_status(event, context):
    """
    구독 상태 확인

    Headers:
        Authorization: Bearer <access_token>

    Response:
        {
            "plan": "pro",
            "expiry_date": "2025-11-23",
            "daily_conversions": -1,
            "usage_today": 15
        }
    """
    try:
        # 1. JWT 토큰 검증
        token = event['headers']['Authorization'].replace('Bearer ', '')

        try:
            payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        except jwt.ExpiredSignatureError:
            return {
                'statusCode': 401,
                'body': json.dumps({'message': '토큰이 만료되었습니다'})
            }
        except jwt.InvalidTokenError:
            return {
                'statusCode': 401,
                'body': json.dumps({'message': '유효하지 않은 토큰입니다'})
            }

        user_id = payload['user_id']

        # 2. 사용자 정보 조회
        response = users_table.get_item(Key={'user_id': user_id})

        if 'Item' not in response:
            return {
                'statusCode': 404,
                'body': json.dumps({'message': '사용자를 찾을 수 없습니다'})
            }

        user = response['Item']

        # 3. 구독 만료 확인
        if user.get('expiry_date'):
            expiry = datetime.fromisoformat(user['expiry_date'])
            if datetime.now() > expiry:
                # 만료됨 → Free 플랜으로 다운그레이드
                users_table.update_item(
                    Key={'user_id': user_id},
                    UpdateExpression='SET plan = :free',
                    ExpressionAttributeValues={':free': 'free'}
                )
                user['plan'] = 'free'

        # 4. 오늘 사용량 조회
        usage_today = get_usage_today(user_id)

        return {
            'statusCode': 200,
            'body': json.dumps({
                'plan': user['plan'],
                'expiry_date': user.get('expiry_date'),
                'daily_conversions': get_daily_limit(user['plan']),
                'usage_today': usage_today
            })
        }

    except Exception as e:
        return {
            'statusCode': 500,
            'body': json.dumps({'message': f'서버 오류: {str(e)}'})
        }

def get_usage_today(user_id):
    """오늘 사용량 조회"""
    usage_table = dynamodb.Table('usage')
    today = datetime.now().strftime('%Y-%m-%d')

    response = usage_table.get_item(
        Key={
            'user_id': user_id,
            'date': today
        }
    )

    if 'Item' in response:
        return response['Item']['count']
    else:
        return 0
```

---

## 🔄 자동 갱신 시스템

### CloudWatch Events + Lambda

```python
# handlers/auto_renewal.py

import json
import boto3
from datetime import datetime, timedelta

dynamodb = boto3.resource('dynamodb')
users_table = dynamodb.Table('users')

def auto_renewal_check(event, context):
    """
    구독 자동 갱신 확인 (매일 자동 실행)

    만료 3일 전 사용자들에게 자동 결제 시도
    """
    expiry_threshold = (datetime.now() + timedelta(days=3)).isoformat()

    # 만료 예정 사용자 조회
    response = users_table.scan(
        FilterExpression='expiry_date <= :threshold AND auto_renewal = :auto',
        ExpressionAttributeValues={
            ':threshold': expiry_threshold,
            ':auto': True
        }
    )

    for user in response['Items']:
        try:
            # 자동 결제 처리
            process_auto_payment(user)

        except Exception as e:
            # 결제 실패 시 이메일 알림
            send_payment_failure_notification(user, str(e))

def process_auto_payment(user):
    """자동 결제 처리"""
    # 토스페이먼츠 자동 결제 API 호출
    import requests

    toss_secret = os.getenv('TOSS_PAYMENTS_SECRET_KEY')

    response = requests.post(
        "https://api.tosspayments.com/v1/billing/subscriptions",
        headers={
            "Authorization": f"Basic {toss_secret}",
            "Content-Type": "application/json"
        },
        json={
            "billingKey": user['billing_key'],
            "orderId": f"order_{user['user_id']}_{datetime.now().timestamp()}",
            "amount": get_plan_price(user['plan'])
        }
    )

    if response.status_code == 200:
        # 결제 성공 → 구독 연장
        new_expiry = datetime.now() + timedelta(days=30)

        users_table.update_item(
            Key={'user_id': user['user_id']},
            UpdateExpression='SET expiry_date = :expiry',
            ExpressionAttributeValues={
                ':expiry': new_expiry.isoformat()
            }
        )

        send_renewal_success_notification(user)
    else:
        raise Exception(f"결제 실패: {response.json()}")

def get_plan_price(plan):
    """플랜별 가격"""
    prices = {
        'basic': 4900,
        'pro': 9900
    }
    return prices.get(plan, 0)
```

---

## 📊 비용 분석 (수정된 실제 비용)

### 인증 관련 API 호출 예상

| 사용자 수 | 월 API 호출 | Lambda 비용 | API Gateway 비용 | DynamoDB 비용 | 총 비용 |
|----------|-----------|------------|----------------|--------------|---------|
| 1,000명 | 12,000회 | ₩0 (무료) | ₩0 (무료) | ₩0 (무료) | **₩0** |
| 10,000명 | 120,000회 | ₩0 (무료) | ₩0 (무료) | ₩0 (무료) | **₩0** |
| 85,000명 | 1,020,000회 | ₩520 | ₩910 | ₩0 (무료) | **₩1,430** |
| 100,000명 | 1,200,000회 | ₩780 | ₩1,365 | ₩0 (무료) | **₩2,145** |

**핵심 포인트**: 8만5천명까지 거의 무료 (고정비 제외)!

---

## 🧪 테스트 시나리오

### 1. 정상 흐름
- 로그인 → 토큰 발급 → 로컬 캐시 저장
- 7일 내 재시작 → 로컬 캐시 사용
- 7일 후 재시작 → 온라인 인증 재시도

### 2. 오프라인 모드
- 네트워크 차단 → 로컬 캐시 사용 (30일 유예)
- 30일 초과 → 온라인 인증 필수

### 3. 기기 변경
- 다른 PC에서 로그인 → 기존 기기 자동 해제 (Pro)
- Free/Basic → 에러 메시지

### 4. 토큰 만료
- Access Token 만료 → Refresh Token으로 갱신
- Refresh Token 만료 → 재로그인 필요

---

> **참조 문서**
> - [서버리스_구독서비스_연동방안.md](../서버리스_구독서비스_연동방안.md)
> - [01_보안_가이드라인.md](../01_보안_가이드라인.md)
> - [task.md](../task.md)
