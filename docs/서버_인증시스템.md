# ì„œë²„ ì¸ì¦ ì‹œìŠ¤í…œ ì„¤ê³„

> **ëª©ì **: ì•ˆì „í•˜ê³  íš¨ìœ¨ì ì¸ í•˜ì´ë¸Œë¦¬ë“œ ì¸ì¦ ì‹œìŠ¤í…œ êµ¬í˜„
> **í•µì‹¬ ì›ì¹™**: ë³´ì•ˆì„±, ì‚¬ìš©ì í¸ì˜ì„±, ë¹„ìš© íš¨ìœ¨ì„±
> **ìµœì¢… ì—…ë°ì´íŠ¸**: 2025-10-23
> **ê´€ë ¨ í´ë”**: `src/auth/`

## ğŸ“ ê´€ë ¨ ì½”ë“œ ìœ„ì¹˜

ì´ ë¬¸ì„œëŠ” ë‹¤ìŒ í´ë”ì˜ êµ¬í˜„ ê°€ì´ë“œì…ë‹ˆë‹¤:
- **src/auth/subscription.py** - SubscriptionManager í´ë˜ìŠ¤, êµ¬ë… ìƒíƒœ ê´€ë¦¬
- **src/auth/security.py** - JWT ê²€ì¦, í•˜ë“œì›¨ì–´ ID ìƒì„±, ì•”í˜¸í™”
- **src/auth/api_client.py** - AWS API í†µì‹ , í† í° ê´€ë¦¬

**ê·œì¹™**:
- ì¸ì¦ ì‹œìŠ¤í…œ ê°œë°œ ì‹œ í•˜ì´ë¸Œë¦¬ë“œ ì¸ì¦ í”Œë¡œìš°ë¥¼ ë°˜ë“œì‹œ ë”°ë¥´ì„¸ìš”
- 7ì¼ ì˜¨ë¼ì¸ ì²´í¬, 30ì¼ ì˜¤í”„ë¼ì¸ ìœ ì˜ˆ ì •ì±… ì¤€ìˆ˜
- ì½”ë“œ ë³€ê²½ ì‹œ ì´ ë¬¸ì„œë„ í•¨ê»˜ ì—…ë°ì´íŠ¸í•˜ì„¸ìš”

---

## ğŸ¯ ì¸ì¦ ì‹œìŠ¤í…œ ê°œìš”

### í•˜ì´ë¸Œë¦¬ë“œ ì¸ì¦ ë°©ì‹

**ì˜¨ë¼ì¸ ì¸ì¦** + **ì˜¤í”„ë¼ì¸ ìœ ì˜ˆ**ë¥¼ ê²°í•©í•œ ë°©ì‹ìœ¼ë¡œ, ì‚¬ìš©ì í¸ì˜ì„±ê³¼ ë¹„ìš© íš¨ìœ¨ì„±ì„ ë™ì‹œì— ë‹¬ì„±í•©ë‹ˆë‹¤.

| êµ¬ë¶„ | ì˜¨ë¼ì¸ ì¸ì¦ | ì˜¤í”„ë¼ì¸ ìœ ì˜ˆ |
|------|-----------|-------------|
| **ì£¼ê¸°** | 7ì¼ë§ˆë‹¤ | ìµœëŒ€ 30ì¼ |
| **ì„œë²„ í˜¸ì¶œ** | Yes | No (ë¡œì»¬ ìºì‹œ) |
| **ë„¤íŠ¸ì›Œí¬ í•„ìš”** | Yes | No |
| **ë¹„ìš©** | API í˜¸ì¶œ ë¹„ìš© | 0ì› |
| **ë³´ì•ˆ** | ë†’ìŒ | ì¤‘ê°„ |

### ì¸ì¦ í”Œë¡œìš°

```
ì•± ì‹œì‘
  â†“
ë¡œì»¬ ìºì‹œ í™•ì¸
  â†“
ìºì‹œ ìˆìŒ? â”€â”€â”€ No â”€â”€â†’ ì˜¨ë¼ì¸ ì¸ì¦ í•„ìˆ˜
  â”‚
 Yes
  â†“
ìºì‹œ ìœ íš¨? (7ì¼ ì´ë‚´)
  â”‚
 Yes â”€â”€â†’ ë¡œì»¬ ì¸ì¦ ì„±ê³µ
  â”‚
 No
  â†“
ë„¤íŠ¸ì›Œí¬ ì—°ê²°?
  â”‚
 Yes â”€â”€â†’ ì˜¨ë¼ì¸ ì¸ì¦
  â”‚
 No
  â†“
ì˜¤í”„ë¼ì¸ ìœ ì˜ˆ (30ì¼) ì²´í¬
  â”‚
ìœ íš¨? â”€â”€â”€ Yes â”€â”€â†’ ì˜¤í”„ë¼ì¸ ëª¨ë“œ
  â”‚
 No
  â†“
ì¸ì¦ ì‹¤íŒ¨ (ì¬ë¡œê·¸ì¸ í•„ìš”)
```

---

## ğŸ” ë³´ì•ˆ ì•„í‚¤í…ì²˜

### JWT í† í° êµ¬ì¡°

```json
{
  "header": {
    "alg": "RS256",
    "typ": "JWT"
  },
  "payload": {
    "user_id": "user_12345",
    "email": "user@example.com",
    "plan": "pro",
    "hardware_id": "abc123def456",
    "exp": 1735689600,  // ë§Œë£Œ ì‹œê°„ (7ì¼ í›„)
    "iat": 1735084800   // ë°œê¸‰ ì‹œê°„
  },
  "signature": "..."
}
```

### í•˜ë“œì›¨ì–´ ID ìƒì„±

```python
import hashlib
import platform
import uuid

def generate_hardware_id():
    """
    í•˜ë“œì›¨ì–´ ê³ ìœ  ID ìƒì„±

    ì¡°í•© ìš”ì†Œ:
    - MAC ì£¼ì†Œ
    - CPU ì •ë³´
    - ë¨¸ì‹  ì •ë³´

    Returns:
        str: 16ìë¦¬ í•˜ë“œì›¨ì–´ ID
    """
    # MAC ì£¼ì†Œ
    mac_address = ':'.join([
        '{:02x}'.format((uuid.getnode() >> i) & 0xff)
        for i in range(0, 8*6, 8)
    ][::-1])

    # CPU ë° ë¨¸ì‹  ì •ë³´
    machine_info = f"{platform.machine()}-{platform.processor()}"

    # SHA-256 í•´ì‹œ
    combined = f"{machine_info}-{mac_address}"
    hardware_hash = hashlib.sha256(combined.encode()).hexdigest()

    return hardware_hash[:16]  # ì• 16ìë¦¬ë§Œ ì‚¬ìš©
```

---

## ğŸ’» í´ë¼ì´ì–¸íŠ¸ ì¸ì¦ ëª¨ë“ˆ

### SubscriptionManager í´ë˜ìŠ¤

```python
import requests
import json
import jwt
import keyring
from datetime import datetime, timedelta
from pathlib import Path

class SubscriptionManager:
    """êµ¬ë… ê´€ë¦¬ í´ë˜ìŠ¤"""

    def __init__(self, api_base_url="https://api.imageconverter.com"):
        self.api_base = api_base_url
        self.token_cache_file = Path.home() / ".imageconverter" / "auth.cache"
        self.hardware_id = generate_hardware_id()
        self.token_cache_file.parent.mkdir(parents=True, exist_ok=True)

    def login(self, email, password):
        """
        ë¡œê·¸ì¸ ë° í† í° ë°œê¸‰

        Args:
            email (str): ì‚¬ìš©ì ì´ë©”ì¼
            password (str): ë¹„ë°€ë²ˆí˜¸

        Returns:
            tuple: (ì„±ê³µ ì—¬ë¶€, ë©”ì‹œì§€)
        """
        try:
            response = requests.post(
                f"{self.api_base}/auth/login",
                json={
                    "email": email,
                    "password": password,
                    "hardware_id": self.hardware_id,
                    "client_version": "1.0.0"
                },
                timeout=10
            )

            if response.status_code == 200:
                data = response.json()
                access_token = data['access_token']
                refresh_token = data['refresh_token']

                # í† í° ì•ˆì „ ì €ì¥ (keyring)
                keyring.set_password("imageconverter", "access_token", access_token)
                keyring.set_password("imageconverter", "refresh_token", refresh_token)

                # ë¡œì»¬ ìºì‹œ ì €ì¥
                self._save_token_cache(data)

                return True, "ë¡œê·¸ì¸ ì„±ê³µ"
            else:
                error_msg = response.json().get('message', 'ë¡œê·¸ì¸ ì‹¤íŒ¨')
                return False, error_msg

        except requests.RequestException as e:
            return False, f"ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜: {e}"

    def check_subscription(self):
        """
        êµ¬ë… ìƒíƒœ í™•ì¸

        Returns:
            tuple: (ì„±ê³µ ì—¬ë¶€, ë©”ì‹œì§€, êµ¬ë… ë°ì´í„°)
        """
        # 1. ë¡œì»¬ ìºì‹œ í™•ì¸
        cache_valid, cache_data = self._check_local_cache()

        if cache_valid:
            return True, "ë¡œì»¬ ì¸ì¦ ì„±ê³µ", cache_data

        # 2. ì˜¨ë¼ì¸ ì¸ì¦ ì‹œë„
        token = keyring.get_password("imageconverter", "access_token")

        if not token:
            return False, "ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤", {}

        try:
            headers = {"Authorization": f"Bearer {token}"}
            response = requests.get(
                f"{self.api_base}/subscription/status",
                headers=headers,
                timeout=10
            )

            if response.status_code == 200:
                data = response.json()

                # ë¡œì»¬ ìºì‹œ ì—…ë°ì´íŠ¸
                self._save_token_cache(data)

                return True, "ì˜¨ë¼ì¸ ì¸ì¦ ì„±ê³µ", data

            elif response.status_code == 401:
                # í† í° ê°±ì‹  ì‹œë„
                if self._refresh_token():
                    return self.check_subscription()  # ì¬ê·€ í˜¸ì¶œ
                else:
                    return False, "ì¸ì¦ ë§Œë£Œ (ì¬ë¡œê·¸ì¸ í•„ìš”)", {}

            else:
                return False, "êµ¬ë… í™•ì¸ ì‹¤íŒ¨", {}

        except requests.RequestException:
            # 3. ì˜¤í”„ë¼ì¸ ëª¨ë“œ (ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜ ì‹œ)
            return self._check_offline_subscription()

    def _check_local_cache(self):
        """
        ë¡œì»¬ ìºì‹œ í™•ì¸ (7ì¼ ì´ë‚´)

        Returns:
            tuple: (ìœ íš¨ ì—¬ë¶€, ìºì‹œ ë°ì´í„°)
        """
        try:
            if not self.token_cache_file.exists():
                return False, {}

            with open(self.token_cache_file, 'r') as f:
                cache_data = json.load(f)

            last_check = datetime.fromisoformat(cache_data['last_check'])

            # 7ì¼ ì´ë‚´ë©´ ìœ íš¨
            if datetime.now() - last_check < timedelta(days=7):
                return True, cache_data['subscription']
            else:
                return False, {}

        except (json.JSONDecodeError, KeyError, ValueError):
            return False, {}

    def _check_offline_subscription(self):
        """
        ì˜¤í”„ë¼ì¸ êµ¬ë… í™•ì¸ (30ì¼ ìœ ì˜ˆ)

        Returns:
            tuple: (ì„±ê³µ ì—¬ë¶€, ë©”ì‹œì§€, êµ¬ë… ë°ì´í„°)
        """
        try:
            if not self.token_cache_file.exists():
                return False, "ì´ˆê¸° ì˜¨ë¼ì¸ ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤", {}

            with open(self.token_cache_file, 'r') as f:
                cache_data = json.load(f)

            last_check = datetime.fromisoformat(cache_data['last_check'])

            # 30ì¼ ì´ë‚´ë©´ ì˜¤í”„ë¼ì¸ ëª¨ë“œ í—ˆìš©
            if datetime.now() - last_check < timedelta(days=30):
                days_left = 30 - (datetime.now() - last_check).days
                return True, f"ì˜¤í”„ë¼ì¸ ëª¨ë“œ ({days_left}ì¼ ë‚¨ìŒ)", cache_data['subscription']
            else:
                return False, "ì˜¨ë¼ì¸ ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤ (30ì¼ ì´ˆê³¼)", {}

        except (json.JSONDecodeError, KeyError, ValueError):
            return False, "ìºì‹œ ë°ì´í„° ì˜¤ë¥˜", {}

    def _refresh_token(self):
        """
        í† í° ê°±ì‹ 

        Returns:
            bool: ê°±ì‹  ì„±ê³µ ì—¬ë¶€
        """
        refresh_token = keyring.get_password("imageconverter", "refresh_token")

        if not refresh_token:
            return False

        try:
            response = requests.post(
                f"{self.api_base}/auth/refresh",
                json={"refresh_token": refresh_token},
                timeout=10
            )

            if response.status_code == 200:
                data = response.json()
                new_token = data['access_token']

                # ìƒˆ í† í° ì €ì¥
                keyring.set_password("imageconverter", "access_token", new_token)

                return True

        except requests.RequestException:
            pass

        return False

    def _save_token_cache(self, data):
        """
        í† í° ìºì‹œ ì €ì¥

        Args:
            data (dict): API ì‘ë‹µ ë°ì´í„°
        """
        cache_data = {
            'last_check': datetime.now().isoformat(),
            'subscription': {
                'plan': data.get('plan', 'free'),
                'expiry_date': data.get('expiry_date'),
                'daily_conversions': data.get('daily_conversions', 5)
            }
        }

        with open(self.token_cache_file, 'w') as f:
            json.dump(cache_data, f)

    def get_user_limits(self, subscription_data):
        """
        êµ¬ë… ë“±ê¸‰ë³„ ì‚¬ìš© ì œí•œ ë°˜í™˜

        Args:
            subscription_data (dict): êµ¬ë… ì •ë³´

        Returns:
            dict: ì‚¬ìš© ì œí•œ ì •ë³´
        """
        plan = subscription_data.get('plan', 'free')

        limits = {
            'free': {
                'daily_conversions': 5,
                'formats': ['webp'],
                'features': ['individual_files'],
                'batch_size': 1
            },
            'basic': {
                'daily_conversions': 50,
                'formats': ['webp', 'avif'],
                'features': ['individual_files', 'folder_conversion', 'scheduling'],
                'batch_size': 10
            },
            'pro': {
                'daily_conversions': -1,  # ë¬´ì œí•œ
                'formats': ['webp', 'avif'],
                'features': ['all'],
                'batch_size': 100
            }
        }

        return limits.get(plan, limits['free'])

    def logout(self):
        """ë¡œê·¸ì•„ì›ƒ (í† í° ì‚­ì œ)"""
        try:
            keyring.delete_password("imageconverter", "access_token")
            keyring.delete_password("imageconverter", "refresh_token")

            if self.token_cache_file.exists():
                self.token_cache_file.unlink()

            return True, "ë¡œê·¸ì•„ì›ƒ ì„±ê³µ"

        except Exception as e:
            return False, f"ë¡œê·¸ì•„ì›ƒ ì˜¤ë¥˜: {e}"
```

---

## ğŸŒ ì„œë²„ ì¸ì¦ API (AWS Lambda)

### 1. ë¡œê·¸ì¸ API

```python
# handlers/auth.py

import json
import jwt
import boto3
import hashlib
from datetime import datetime, timedelta

SECRET_KEY = os.getenv('JWT_SECRET_KEY')
ALGORITHM = 'RS256'

dynamodb = boto3.resource('dynamodb')
users_table = dynamodb.Table('users')

def authenticate(event, context):
    """
    ì‚¬ìš©ì ë¡œê·¸ì¸

    Request Body:
        {
            "email": "user@example.com",
            "password": "password123",
            "hardware_id": "abc123def456",
            "client_version": "1.0.0"
        }

    Response:
        {
            "access_token": "...",
            "refresh_token": "...",
            "plan": "pro",
            "expiry_date": "2025-11-23"
        }
    """
    try:
        body = json.loads(event['body'])
        email = body['email']
        password = body['password']
        hardware_id = body['hardware_id']

        # 1. ì‚¬ìš©ì í™•ì¸
        response = users_table.get_item(Key={'email': email})

        if 'Item' not in response:
            return {
                'statusCode': 401,
                'body': json.dumps({'message': 'ì´ë©”ì¼ ë˜ëŠ” ë¹„ë°€ë²ˆí˜¸ê°€ ì˜ëª»ë˜ì—ˆìŠµë‹ˆë‹¤'})
            }

        user = response['Item']

        # 2. ë¹„ë°€ë²ˆí˜¸ í™•ì¸
        password_hash = hashlib.sha256(password.encode()).hexdigest()

        if user['password_hash'] != password_hash:
            return {
                'statusCode': 401,
                'body': json.dumps({'message': 'ì´ë©”ì¼ ë˜ëŠ” ë¹„ë°€ë²ˆí˜¸ê°€ ì˜ëª»ë˜ì—ˆìŠµë‹ˆë‹¤'})
            }

        # 3. í•˜ë“œì›¨ì–´ ID í™•ì¸/ì—…ë°ì´íŠ¸
        if 'hardware_id' in user and user['hardware_id'] != hardware_id:
            # ê¸°ê¸° ë³€ê²½ í™•ì¸ (Pro í”Œëœì€ í—ˆìš©, Free/Basicì€ ì œí•œ)
            if user['plan'] in ['free', 'basic']:
                return {
                    'statusCode': 403,
                    'body': json.dumps({'message': 'ë‹¤ë¥¸ ê¸°ê¸°ì—ì„œ ì´ë¯¸ ì‚¬ìš© ì¤‘ì…ë‹ˆë‹¤'})
                }

        # 4. JWT í† í° ìƒì„±
        access_token = create_access_token(user, hardware_id)
        refresh_token = create_refresh_token(user)

        # 5. í•˜ë“œì›¨ì–´ ID ì €ì¥
        users_table.update_item(
            Key={'email': email},
            UpdateExpression='SET hardware_id = :hw, last_login = :now',
            ExpressionAttributeValues={
                ':hw': hardware_id,
                ':now': datetime.now().isoformat()
            }
        )

        return {
            'statusCode': 200,
            'body': json.dumps({
                'access_token': access_token,
                'refresh_token': refresh_token,
                'plan': user['plan'],
                'expiry_date': user.get('expiry_date'),
                'daily_conversions': get_daily_limit(user['plan'])
            })
        }

    except Exception as e:
        return {
            'statusCode': 500,
            'body': json.dumps({'message': f'ì„œë²„ ì˜¤ë¥˜: {str(e)}'})
        }

def create_access_token(user, hardware_id):
    """Access Token ìƒì„± (7ì¼ ìœ íš¨)"""
    payload = {
        'user_id': user['user_id'],
        'email': user['email'],
        'plan': user['plan'],
        'hardware_id': hardware_id,
        'exp': datetime.utcnow() + timedelta(days=7),
        'iat': datetime.utcnow()
    }

    return jwt.encode(payload, SECRET_KEY, algorithm=ALGORITHM)

def create_refresh_token(user):
    """Refresh Token ìƒì„± (30ì¼ ìœ íš¨)"""
    payload = {
        'user_id': user['user_id'],
        'exp': datetime.utcnow() + timedelta(days=30),
        'iat': datetime.utcnow()
    }

    return jwt.encode(payload, SECRET_KEY, algorithm=ALGORITHM)

def get_daily_limit(plan):
    """í”Œëœë³„ ì¼ì¼ ë³€í™˜ í•œë„"""
    limits = {
        'free': 5,
        'basic': 50,
        'pro': -1  # ë¬´ì œí•œ
    }
    return limits.get(plan, 5)
```

### 2. êµ¬ë… ìƒíƒœ í™•ì¸ API

```python
# handlers/subscription.py

import json
import jwt
import boto3
from datetime import datetime

SECRET_KEY = os.getenv('JWT_SECRET_KEY')
ALGORITHM = 'RS256'

dynamodb = boto3.resource('dynamodb')
users_table = dynamodb.Table('users')

def check_status(event, context):
    """
    êµ¬ë… ìƒíƒœ í™•ì¸

    Headers:
        Authorization: Bearer <access_token>

    Response:
        {
            "plan": "pro",
            "expiry_date": "2025-11-23",
            "daily_conversions": -1,
            "usage_today": 15
        }
    """
    try:
        # 1. JWT í† í° ê²€ì¦
        token = event['headers']['Authorization'].replace('Bearer ', '')

        try:
            payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        except jwt.ExpiredSignatureError:
            return {
                'statusCode': 401,
                'body': json.dumps({'message': 'í† í°ì´ ë§Œë£Œë˜ì—ˆìŠµë‹ˆë‹¤'})
            }
        except jwt.InvalidTokenError:
            return {
                'statusCode': 401,
                'body': json.dumps({'message': 'ìœ íš¨í•˜ì§€ ì•Šì€ í† í°ì…ë‹ˆë‹¤'})
            }

        user_id = payload['user_id']

        # 2. ì‚¬ìš©ì ì •ë³´ ì¡°íšŒ
        response = users_table.get_item(Key={'user_id': user_id})

        if 'Item' not in response:
            return {
                'statusCode': 404,
                'body': json.dumps({'message': 'ì‚¬ìš©ìë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤'})
            }

        user = response['Item']

        # 3. êµ¬ë… ë§Œë£Œ í™•ì¸
        if user.get('expiry_date'):
            expiry = datetime.fromisoformat(user['expiry_date'])
            if datetime.now() > expiry:
                # ë§Œë£Œë¨ â†’ Free í”Œëœìœ¼ë¡œ ë‹¤ìš´ê·¸ë ˆì´ë“œ
                users_table.update_item(
                    Key={'user_id': user_id},
                    UpdateExpression='SET plan = :free',
                    ExpressionAttributeValues={':free': 'free'}
                )
                user['plan'] = 'free'

        # 4. ì˜¤ëŠ˜ ì‚¬ìš©ëŸ‰ ì¡°íšŒ
        usage_today = get_usage_today(user_id)

        return {
            'statusCode': 200,
            'body': json.dumps({
                'plan': user['plan'],
                'expiry_date': user.get('expiry_date'),
                'daily_conversions': get_daily_limit(user['plan']),
                'usage_today': usage_today
            })
        }

    except Exception as e:
        return {
            'statusCode': 500,
            'body': json.dumps({'message': f'ì„œë²„ ì˜¤ë¥˜: {str(e)}'})
        }

def get_usage_today(user_id):
    """ì˜¤ëŠ˜ ì‚¬ìš©ëŸ‰ ì¡°íšŒ"""
    usage_table = dynamodb.Table('usage')
    today = datetime.now().strftime('%Y-%m-%d')

    response = usage_table.get_item(
        Key={
            'user_id': user_id,
            'date': today
        }
    )

    if 'Item' in response:
        return response['Item']['count']
    else:
        return 0
```

---

## ğŸ”„ ìë™ ê°±ì‹  ì‹œìŠ¤í…œ

### CloudWatch Events + Lambda

```python
# handlers/auto_renewal.py

import json
import boto3
from datetime import datetime, timedelta

dynamodb = boto3.resource('dynamodb')
users_table = dynamodb.Table('users')

def auto_renewal_check(event, context):
    """
    êµ¬ë… ìë™ ê°±ì‹  í™•ì¸ (ë§¤ì¼ ìë™ ì‹¤í–‰)

    ë§Œë£Œ 3ì¼ ì „ ì‚¬ìš©ìë“¤ì—ê²Œ ìë™ ê²°ì œ ì‹œë„
    """
    expiry_threshold = (datetime.now() + timedelta(days=3)).isoformat()

    # ë§Œë£Œ ì˜ˆì • ì‚¬ìš©ì ì¡°íšŒ
    response = users_table.scan(
        FilterExpression='expiry_date <= :threshold AND auto_renewal = :auto',
        ExpressionAttributeValues={
            ':threshold': expiry_threshold,
            ':auto': True
        }
    )

    for user in response['Items']:
        try:
            # ìë™ ê²°ì œ ì²˜ë¦¬
            process_auto_payment(user)

        except Exception as e:
            # ê²°ì œ ì‹¤íŒ¨ ì‹œ ì´ë©”ì¼ ì•Œë¦¼
            send_payment_failure_notification(user, str(e))

def process_auto_payment(user):
    """ìë™ ê²°ì œ ì²˜ë¦¬"""
    # í† ìŠ¤í˜ì´ë¨¼ì¸  ìë™ ê²°ì œ API í˜¸ì¶œ
    import requests

    toss_secret = os.getenv('TOSS_PAYMENTS_SECRET_KEY')

    response = requests.post(
        "https://api.tosspayments.com/v1/billing/subscriptions",
        headers={
            "Authorization": f"Basic {toss_secret}",
            "Content-Type": "application/json"
        },
        json={
            "billingKey": user['billing_key'],
            "orderId": f"order_{user['user_id']}_{datetime.now().timestamp()}",
            "amount": get_plan_price(user['plan'])
        }
    )

    if response.status_code == 200:
        # ê²°ì œ ì„±ê³µ â†’ êµ¬ë… ì—°ì¥
        new_expiry = datetime.now() + timedelta(days=30)

        users_table.update_item(
            Key={'user_id': user['user_id']},
            UpdateExpression='SET expiry_date = :expiry',
            ExpressionAttributeValues={
                ':expiry': new_expiry.isoformat()
            }
        )

        send_renewal_success_notification(user)
    else:
        raise Exception(f"ê²°ì œ ì‹¤íŒ¨: {response.json()}")

def get_plan_price(plan):
    """í”Œëœë³„ ê°€ê²©"""
    prices = {
        'basic': 4900,
        'pro': 9900
    }
    return prices.get(plan, 0)
```

---

## ğŸ“Š ë¹„ìš© ë¶„ì„ (ìˆ˜ì •ëœ ì‹¤ì œ ë¹„ìš©)

### ì¸ì¦ ê´€ë ¨ API í˜¸ì¶œ ì˜ˆìƒ

| ì‚¬ìš©ì ìˆ˜ | ì›” API í˜¸ì¶œ | Lambda ë¹„ìš© | API Gateway ë¹„ìš© | DynamoDB ë¹„ìš© | ì´ ë¹„ìš© |
|----------|-----------|------------|----------------|--------------|---------|
| 1,000ëª… | 12,000íšŒ | â‚©0 (ë¬´ë£Œ) | â‚©0 (ë¬´ë£Œ) | â‚©0 (ë¬´ë£Œ) | **â‚©0** |
| 10,000ëª… | 120,000íšŒ | â‚©0 (ë¬´ë£Œ) | â‚©0 (ë¬´ë£Œ) | â‚©0 (ë¬´ë£Œ) | **â‚©0** |
| 85,000ëª… | 1,020,000íšŒ | â‚©520 | â‚©910 | â‚©0 (ë¬´ë£Œ) | **â‚©1,430** |
| 100,000ëª… | 1,200,000íšŒ | â‚©780 | â‚©1,365 | â‚©0 (ë¬´ë£Œ) | **â‚©2,145** |

**í•µì‹¬ í¬ì¸íŠ¸**: 8ë§Œ5ì²œëª…ê¹Œì§€ ê±°ì˜ ë¬´ë£Œ (ê³ ì •ë¹„ ì œì™¸)!

---

## ğŸ§ª í…ŒìŠ¤íŠ¸ ì‹œë‚˜ë¦¬ì˜¤

### 1. ì •ìƒ íë¦„
- ë¡œê·¸ì¸ â†’ í† í° ë°œê¸‰ â†’ ë¡œì»¬ ìºì‹œ ì €ì¥
- 7ì¼ ë‚´ ì¬ì‹œì‘ â†’ ë¡œì»¬ ìºì‹œ ì‚¬ìš©
- 7ì¼ í›„ ì¬ì‹œì‘ â†’ ì˜¨ë¼ì¸ ì¸ì¦ ì¬ì‹œë„

### 2. ì˜¤í”„ë¼ì¸ ëª¨ë“œ
- ë„¤íŠ¸ì›Œí¬ ì°¨ë‹¨ â†’ ë¡œì»¬ ìºì‹œ ì‚¬ìš© (30ì¼ ìœ ì˜ˆ)
- 30ì¼ ì´ˆê³¼ â†’ ì˜¨ë¼ì¸ ì¸ì¦ í•„ìˆ˜

### 3. ê¸°ê¸° ë³€ê²½
- ë‹¤ë¥¸ PCì—ì„œ ë¡œê·¸ì¸ â†’ ê¸°ì¡´ ê¸°ê¸° ìë™ í•´ì œ (Pro)
- Free/Basic â†’ ì—ëŸ¬ ë©”ì‹œì§€

### 4. í† í° ë§Œë£Œ
- Access Token ë§Œë£Œ â†’ Refresh Tokenìœ¼ë¡œ ê°±ì‹ 
- Refresh Token ë§Œë£Œ â†’ ì¬ë¡œê·¸ì¸ í•„ìš”

---

> **ì°¸ì¡° ë¬¸ì„œ**
> - [ì„œë²„ë¦¬ìŠ¤_êµ¬ë…ì„œë¹„ìŠ¤_ì—°ë™ë°©ì•ˆ.md](../ì„œë²„ë¦¬ìŠ¤_êµ¬ë…ì„œë¹„ìŠ¤_ì—°ë™ë°©ì•ˆ.md)
> - [01_ë³´ì•ˆ_ê°€ì´ë“œë¼ì¸.md](../01_ë³´ì•ˆ_ê°€ì´ë“œë¼ì¸.md)
> - [task.md](../task.md)
