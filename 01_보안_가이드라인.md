# 🔐 이미지변환기 보안 가이드라인

> **⚠️ 개발 시 필수 참조 문서**  
> 모든 코딩 작업 전에 반드시 이 문서를 확인하세요!

---

## 🚨 절대 원칙 (NEVER)

### **절대 GitHub에 올리면 안 되는 것들**
- ❌ **API 키 및 비밀키**: `*.key`, `*.pem`, `*.p12`, `*.pfx`
- ❌ **환경 변수 파일**: `.env`, `.env.local`, `.env.production`
- ❌ **비밀 설정 파일**: `secrets.py`, `config.secret.py`, `aws_credentials.json`
- ❌ **사용자 데이터**: `user_data/`, `logs/`, `temp/`, `cache/`
- ❌ **하드코딩된 패스워드**: 코드 내 직접 입력된 비밀번호
- ❌ **데이터베이스 설정**: `database.config`, `db_credentials.py`

### **절대 하지 말아야 할 행동**
- ❌ 비밀키를 코드에 직접 입력
- ❌ .env 파일을 git에 추가
- ❌ 보안 검사 없이 커밋
- ❌ 기본 패스워드 사용
- ❌ HTTP 통신 사용 (HTTPS만!)

---

## ✅ 필수 보안 설정

### **1. .gitignore 설정 (최우선!)**
```gitignore
# 보안 관련 파일들 (절대 커밋 금지!)
*.key
*.pem
*.p12
*.pfx
secrets.py
config.secret.py
.env*
!.env.example
aws_credentials.json
server_config.json
database.config
db_credentials.py

# 사용자 데이터 및 로그
user_data/
logs/
temp/
cache/
*.log

# 빌드 결과물
dist/
build/
*.exe
*.dmg
*.AppImage
*.msi

# 개발 환경 파일
.vscode/settings.json
.idea/
__pycache__/
*.pyc
*.pyo
*.pyd
.Python
.coverage
.pytest_cache/

# 시스템 파일
.DS_Store
Thumbs.db
desktop.ini

# 백업 파일
*.backup
*.bak
*.tmp
*~
```

### **2. 환경 변수 관리**

#### **.env.example (GitHub에 올리는 템플릿)**
```env
# 환경 변수 템플릿 - 실제 값은 입력하지 마세요!
AWS_ACCESS_KEY_ID=your_aws_access_key_here
AWS_SECRET_ACCESS_KEY=your_aws_secret_key_here
JWT_SECRET_KEY=your_super_secret_jwt_key_here
TOSS_PAYMENTS_SECRET_KEY=your_toss_payments_secret_key_here
GITHUB_TOKEN=your_github_token_here
ENCRYPTION_KEY=your_encryption_key_here
ENVIRONMENT=development
```

#### **.env (실제 사용, .gitignore에 포함)**
```env
# 실제 값들 - 절대 GitHub에 올리지 않음!
AWS_ACCESS_KEY_ID=AKIA1234567890EXAMPLE
AWS_SECRET_ACCESS_KEY=abcdef1234567890abcdef1234567890abcdef12
JWT_SECRET_KEY=super-secret-jwt-key-that-nobody-should-know
TOSS_PAYMENTS_SECRET_KEY=test_sk_123456789012345678901234567890
GITHUB_TOKEN=ghp_1234567890abcdef1234567890abcdef123456
ENCRYPTION_KEY=32-byte-encryption-key-for-local-data-encryption
ENVIRONMENT=development
```

### **3. GitHub Secrets 설정**
GitHub Repository → Settings → Secrets and variables → Actions

**필수 Secrets:**
- `AWS_ACCESS_KEY_ID`
- `AWS_SECRET_ACCESS_KEY`
- `JWT_SECRET_KEY`
- `TOSS_PAYMENTS_SECRET_KEY`
- `GITHUB_TOKEN`
- `ENCRYPTION_KEY`
- `WINDOWS_CERTIFICATE` (코드 서명용)
- `APPLE_CERTIFICATE` (macOS 서명용)

---

## 🛡️ 보안 코드 구현

### **환경 변수 관리 클래스**
```python
class SecureConfig:
    """보안 설정 관리 - 환경 변수 기반"""
    
    def __init__(self):
        from dotenv import load_dotenv
        import os
        
        # .env 파일 로드
        load_dotenv()
        
        # 환경 변수에서만 읽기
        self.aws_access_key = os.getenv('AWS_ACCESS_KEY_ID')
        self.aws_secret_key = os.getenv('AWS_SECRET_ACCESS_KEY')
        self.jwt_secret = os.getenv('JWT_SECRET_KEY')
        self.toss_secret = os.getenv('TOSS_PAYMENTS_SECRET_KEY')
        self.encryption_key = os.getenv('ENCRYPTION_KEY')
        
        # 필수 키 검증
        self.validate_required_keys()
    
    def validate_required_keys(self):
        """필수 키들이 설정되었는지 확인"""
        required_keys = [
            ('AWS_ACCESS_KEY_ID', self.aws_access_key),
            ('AWS_SECRET_ACCESS_KEY', self.aws_secret_key),
            ('JWT_SECRET_KEY', self.jwt_secret),
            ('ENCRYPTION_KEY', self.encryption_key)
        ]
        
        missing_keys = [key for key, value in required_keys if not value]
        if missing_keys:
            raise ValueError(f"필수 환경 변수 누락: {', '.join(missing_keys)}")
    
    def get_aws_config(self):
        """AWS 설정 반환"""
        return {
            'aws_access_key_id': self.aws_access_key,
            'aws_secret_access_key': self.aws_secret_key,
            'region_name': 'ap-northeast-2'
        }
```

### **데이터 암호화 클래스**
```python
class SecureStorage:
    """로컬 데이터 보안 저장"""
    
    def __init__(self):
        self.config = SecureConfig()
        
    def encrypt_data(self, data):
        """데이터 암호화"""
        from cryptography.fernet import Fernet
        import base64
        
        # 암호화 키 생성
        key = base64.urlsafe_b64encode(self.config.encryption_key.encode()[:32])
        cipher = Fernet(key)
        
        # 데이터 암호화
        if isinstance(data, str):
            data = data.encode()
        
        encrypted = cipher.encrypt(data)
        return base64.b64encode(encrypted).decode()
    
    def decrypt_data(self, encrypted_data):
        """데이터 복호화"""
        from cryptography.fernet import Fernet
        import base64
        
        try:
            key = base64.urlsafe_b64encode(self.config.encryption_key.encode()[:32])
            cipher = Fernet(key)
            
            encrypted_bytes = base64.b64decode(encrypted_data.encode())
            decrypted = cipher.decrypt(encrypted_bytes)
            
            return decrypted.decode()
        except Exception as e:
            raise SecurityError(f"데이터 복호화 실패: {e}")
    
    def secure_save(self, data, file_path):
        """보안 파일 저장"""
        import json
        import os
        
        encrypted_data = self.encrypt_data(json.dumps(data))
        
        with open(file_path, 'w') as f:
            f.write(encrypted_data)
        
        # 파일 권한 설정 (소유자만 읽기/쓰기)
        os.chmod(file_path, 0o600)
```

### **네트워크 보안 클래스**
```python
class NetworkSecurity:
    """네트워크 통신 보안"""
    
    @staticmethod
    def secure_request(url, data=None, headers=None):
        """보안 HTTP 요청"""
        import requests
        import urllib.parse
        
        # URL 검증
        parsed = urllib.parse.urlparse(url)
        
        # HTTPS만 허용
        if parsed.scheme != 'https':
            raise SecurityError("HTTPS URL만 허용됩니다")
        
        # 허용된 도메인만
        allowed_domains = [
            'api.github.com', 'github.com',
            'amazonaws.com', 'toss.im'
        ]
        
        if not any(domain in parsed.netloc for domain in allowed_domains):
            raise SecurityError(f"허용되지 않은 도메인: {parsed.netloc}")
        
        # 보안 헤더 설정
        secure_headers = {
            'User-Agent': 'ImageConverter/1.0',
            'Accept': 'application/json',
            'Content-Type': 'application/json'
        }
        
        if headers:
            secure_headers.update(headers)
        
        try:
            if data:
                response = requests.post(url, json=data, headers=secure_headers, 
                                       timeout=10, verify=True)
            else:
                response = requests.get(url, headers=secure_headers, 
                                      timeout=10, verify=True)
            
            response.raise_for_status()
            return response.json()
            
        except requests.exceptions.SSLError:
            raise SecurityError("SSL 인증서 검증 실패")
        except requests.exceptions.Timeout:
            raise SecurityError("요청 시간 초과")
        except Exception as e:
            raise SecurityError(f"네트워크 오류: {e}")

class SecurityError(Exception):
    """보안 관련 예외"""
    pass
```

---

## 🔍 보안 검증 도구

### **보안 스캐너**
```python
import os
import re
import glob

class SecurityValidator:
    """코드 보안 검증"""
    
    @staticmethod
    def scan_for_secrets(file_path):
        """파일에서 비밀키 패턴 검색"""
        secret_patterns = [
            r'aws_access_key_id\s*=\s*["\'][A-Z0-9]{20}["\']',
            r'aws_secret_access_key\s*=\s*["\'][A-Za-z0-9/+=]{40}["\']',
            r'sk_[a-zA-Z0-9]{32,}',  # Toss Payments 키
            r'ghp_[a-zA-Z0-9]{36}',  # GitHub 토큰
            r'password\s*=\s*["\'][^"\']{8,}["\']',
            r'secret\s*=\s*["\'][^"\']{16,}["\']'
        ]
        
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
                
            found_secrets = []
            for pattern in secret_patterns:
                matches = re.findall(pattern, content, re.IGNORECASE)
                if matches:
                    found_secrets.extend(matches)
            
            return found_secrets
        except:
            return []
    
    @staticmethod
    def check_all_files():
        """모든 파일 보안 검사"""
        python_files = glob.glob("**/*.py", recursive=True)
        found_issues = False
        
        for file_path in python_files:
            # .gitignore 된 파일은 제외
            if any(ignore in file_path for ignore in ['.git', '__pycache__', '.env']):
                continue
                
            secrets = SecurityValidator.scan_for_secrets(file_path)
            if secrets:
                print(f"⚠️ 보안 위험 발견: {file_path}")
                for secret in secrets:
                    print(f"   - {secret[:30]}...")
                found_issues = True
        
        if not found_issues:
            print("✅ 보안 검사 통과")
            return True
        else:
            print("❌ 보안 검사 실패")
            return False
    
    @staticmethod
    def check_gitignore():
        """필수 .gitignore 항목 확인"""
        required_items = [".env*", "*.key", "*.pem", "secrets.py", "user_data/", "logs/"]
        
        if not os.path.exists(".gitignore"):
            print("❌ .gitignore 파일이 없습니다!")
            return False
        
        with open(".gitignore", "r") as f:
            gitignore_content = f.read()
        
        missing_items = []
        for item in required_items:
            if item not in gitignore_content:
                missing_items.append(item)
        
        if missing_items:
            print(f"❌ .gitignore에 다음 항목들이 누락: {missing_items}")
            return False
        else:
            print("✅ .gitignore 검사 통과")
            return True
```

---

## 📋 GitHub 업로드 체크리스트

### **업로드 전 필수 확인**
- [ ] `.gitignore` 파일이 모든 보안 파일을 포함하고 있는가?
- [ ] `.env.example`은 있지만 실제 `.env`는 `.gitignore`에 포함되었는가?
- [ ] `python security_check.py` 실행 결과가 통과인가?
- [ ] `git status`에서 민감한 파일이 보이지 않는가?
- [ ] `git add --dry-run .` 결과에 보안 파일이 없는가?
- [ ] 코드에 하드코딩된 패스워드가 없는가?

### **업로드 후 필수 확인**
- [ ] GitHub에서 `.env` 파일이 보이지 않는가?
- [ ] GitHub Secrets가 모두 설정되었는가?
- [ ] Repository가 Private으로 설정되었는가?
- [ ] 보안 파일들이 모두 제외되었는가?
- [ ] 브랜치 보호 규칙이 설정되었는가?

---

## 🚨 비상시 대응 절차

### **비밀키 누출 시 대응**
1. **즉시 API 키 무효화**
   - AWS, Toss Payments 등에서 해당 키 즉시 삭제
   - GitHub Token 즉시 재생성

2. **Git 히스토리에서 완전 제거**
   ```bash
   git filter-branch --force --index-filter \
   'git rm --cached --ignore-unmatch .env secrets.py' \
   --prune-empty --tag-name-filter cat -- --all
   
   git push origin --force --all
   ```

3. **새로운 키 생성 및 재배포**
   - 모든 환경에 새 키 적용
   - GitHub Secrets 업데이트
   - 사용자들에게 긴급 업데이트 배포

### **보안 사고 보고**
- 사고 발생 시간 기록
- 영향 범위 파악
- 대응 조치 내역 문서화
- 재발 방지 계획 수립

---

## 🛠️ 개발 시 보안 명령어

### **자동 보안 검사 설정 (권장!)**
```bash
# Git Hooks 자동 설정 (한 번만 실행)
# Windows:
이미지변환기_프로젝트\install_security_hooks.bat

# Linux/macOS:
./이미지변환기_프로젝트/install_security_hooks.sh

# 또는 수동 설정:
python 이미지변환기_프로젝트/setup_git_hooks.py install
```

### **설정 후 커밋 과정**
```bash
# 이제 커밋할 때 자동으로 보안 검사 실행!
git add .
git commit -m "커밋 메시지"  # 자동으로 보안 검사 실행됨
git push origin main
```

### **수동 보안 검사 (필요시)**
```bash
# 커밋 전 수동 보안 검사
python 이미지변환기_프로젝트/security_check.py

# Hook 상태 확인
python 이미지변환기_프로젝트/setup_git_hooks.py status

# Hook 제거
python 이미지변환기_프로젝트/setup_git_hooks.py remove
```

### **정기 보안 점검 (주 1회)**
```bash
# 의존성 보안 취약점 검사
pip audit

# 코드 보안 스캔
bandit -r . -f json -o security_report.json

# .gitignore 설정 재확인
cat .gitignore
```

---

## 🎯 보안 원칙 요약

### **Golden Rules (황금 규칙)**
1. **Never commit secrets** - 절대 비밀키를 커밋하지 않기
2. **Environment variables only** - 환경 변수로만 민감 정보 관리
3. **Encrypt everything** - 모든 로컬 데이터 암호화
4. **HTTPS only** - HTTPS 통신만 허용
5. **Regular rotation** - 정기적인 키 교체
6. **Validate always** - 항상 입력값 검증
7. **Monitor continuously** - 지속적인 보안 모니터링

### **개발자 마음가짐**
- 🔐 **보안은 선택이 아닌 필수**
- 🚨 **의심스러우면 하지 않기**
- ✅ **매번 검증하고 확인하기**
- 📚 **보안 가이드 수시로 참조하기**
- 🤝 **보안 문제 발견 시 즉시 공유**

---

## 📞 보안 문제 발생 시 연락처

- **긴급 상황**: 즉시 개발 중단 후 보안 검토
- **의심 사항**: 확실하지 않으면 반드시 문의
- **보안 업데이트**: 새로운 보안 위협 발견 시 즉시 공유

---

> **🔥 이 문서는 개발의 생명줄입니다!**  
> 매번 코딩 전에 확인하고, 의심스러우면 반드시 재검토하세요!

**마지막 업데이트**: 2025-09-19  
**다음 검토 예정일**: 매주 금요일
